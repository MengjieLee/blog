<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MySQL-事务</title>
    <link href="/blog/2024/10/05/MySQL-%E4%BA%8B%E5%8A%A1/"/>
    <url>/blog/2024/10/05/MySQL-%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="知识总览"><a href="#知识总览" class="headerlink" title="知识总览"></a>知识总览</h2><ul><li>事务的隔离级别如何实现？</li><li>事务有哪些特性？</li><li>并行事务会引发脏读、不可重复读、幻读问题</li><li>事务的隔离级别有哪些？</li><li>Read View 在 MVCC 里如何工作？</li><li>可重复读是如何工作的？</li><li>读提交时如何工作的？</li><li>MySQL 可重复读隔离级别，完全解决欢度了吗？</li><li>什么是幻读？</li><li>快照读是如何避免幻读的?</li><li>当前读是如何避免幻读的？</li><li>幻读被完全解决了吗？</li><li>总结</li></ul><p>事务（Transaction）解决业务里的所有数据库的操作不可分割，要么全部成功，要么全部失败，不允许出现中间状态的数据。</p><p>事务是由 MySQL 引擎来实现的，常见的 InnoDB 引擎是支持事务的。</p><h2 id="事务有哪些特性？"><a href="#事务有哪些特性？" class="headerlink" title="事务有哪些特性？"></a>事务有哪些特性？</h2><p>实现事务必须要遵循 4 个特性<code>ACID</code>：</p><ul><li><code>原子性 (Atomicity)</code>：一个事务的所有操作，要么全部完成，要么全部不完成，执行过程发生错误，会被回滚到事务开始前的状态。</li><li><code>一致性（Consistency）</code>：事务操作前、后的数据满足完整性约束，数据库保持一致性状态。如银行中两个用户A,B总共金额2000元，不管他们如何交易，总数不能变。</li><li><code>隔离性（Isolation）</code>：数据库允许多个并发事务同时对其数据进行读写和修改，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。也就是说消费者购买商品这个事务，是不影响其他消费者同时购买的。</li><li><code>持久性（Durability）</code>：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li></ul><p>InnoDB 引擎通过什么技术来保证事务的 ACID：</p><ul><li><code>原子性</code>是通过<code>undo log（回滚日志）</code>来实现</li><li><code>一致性</code>是通过<code>持久性+原子性+隔离性</code>来保证</li><li><code>隔离性</code>是通过<code>MVCC（多版本并发控制）或锁机制</code>来实现</li><li><code>持久性</code>是通过<code>redo log（重做日志）</code>来实现</li></ul><h2 id="并行事务会引发什么问题？"><a href="#并行事务会引发什么问题？" class="headerlink" title="并行事务会引发什么问题？"></a>并行事务会引发什么问题？</h2><p>MySQL 服务端是允许多个 client 连接的，这意味着 MySQL 会出现同时处理多个事务的情况。<br>那么在同时处理多个事务的时候，就可能出现：</p><ul><li><code>脏读（dirty read）</code></li><li><code>不可重复读（non-repeatable read）</code></li><li><code>幻读（phantom read）</code></li></ul><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>如果一个事务B<code>读到</code>了另一个事务A<code>未提交事务修改过的数据</code>，就意味着发生了<code>脏读</code>现象。如下所示：</p><p>事务A–&gt;启动事务–&gt;读取余额–&gt;更新余额–&gt;触发回滚—–&gt;结束<br>数据库———— 100 —— 200 —- <code>100</code> ———<br>事务B–&gt;启动事务———-&gt;读取余额<code>200</code>————&gt;结束</p><p>因为事务A是还没提交更新事务，随时可能发生回滚，事务B所得到的数据就是过期的数据，这种现象就称谓<code>脏读</code>。</p><h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>如果一个事务内多次读取同一个数据，如果出现前后两次读出的数据不一样的情况，就意味着发生了<code>不可重复读</code>现象。如下所示：</p><p>事务A–&gt;启动事务–&gt;读取余额—–&gt;更新余额–&gt;提交事务———&gt;结束<br>数据库———–    100   ——       200     ————<br>事务B–&gt;启动事务–&gt;读取余额<code>100</code>—&gt;读取余额<code>200</code>  ———&gt;结束</p><h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><p>如果一个事务内多次查询某个复合查询条件的结果出现不一致，则意味着发生了<code>幻读</code>现象.</p><p>事务A–&gt;启动事务–&gt;读取价格大于100的商品数量—–&gt;插入一条价格为150商品—&gt;提交事务———&gt;结束<br>数据库————        10           ——-              11            ————<br>事务B–&gt;启动事务–&gt;读取价格大于100的商品数量<code>10</code>–&gt;读取价格大于100的商品数量<code>11</code>  ———-&gt;结束</p><h2 id="事务的隔离级别有哪些？"><a href="#事务的隔离级别有哪些？" class="headerlink" title="事务的隔离级别有哪些？"></a>事务的隔离级别有哪些？</h2><p>TODO</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>事务</tag>
      
      <tag>MySQL 事务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 索引</title>
    <link href="/blog/2024/09/29/MySQL-%E7%B4%A2%E5%BC%95/"/>
    <url>/blog/2024/09/29/MySQL-%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<h2 id="知识总览"><a href="#知识总览" class="headerlink" title="知识总览"></a>知识总览</h2><p>MySQL 索引相关的内容，可以从索引原理–&gt;索引场景来展开分析，比如：</p><ul><li>索引底层使用了什么数据结构和算法？</li><li>MySQL InnoDB 为什么选择 B+ tree？</li><li>索引的优缺点？什么时候适用？什么情况会失效？</li><li>聚簇/非聚簇索引特点？</li><li>索引分类？</li><li>什么是组合、复合、联合？</li><li>InnoDB 和 MyISAM 索引区别？</li><li>索引排序内部流程是什么？</li><li>Order By 能否通过索引排序？</li><li>有什么优化索引的方法？</li><li>。。。<img src="/blog/2024/09/29/MySQL-%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E7%9F%A5%E8%AF%86%E7%9B%98%E7%82%B9.png" class=""></li></ul><h2 id="什么是索引？"><a href="#什么是索引？" class="headerlink" title="什么是索引？"></a>什么是索引？</h2><p>形象直白来讲，索引就是数据的目录。<br>所谓的存储引擎，说白就是为了如何存储数据，如何为存储数据建立<code>索引</code>和实现<code>高效CRUD操作</code>。<br>下面是 MySQL 逻辑结构缩图，索引和数据都位于存储引擎中。</p><img src="/blog/2024/09/29/MySQL-%E7%B4%A2%E5%BC%95/MySQL-%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%E5%9B%BE.png" class=""><h2 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h2><p>四个角度分类索引：</p><ul><li><code>数据结构</code>分裂： B+tree、Hash、Full-text</li><li><code>物理存储</code>分类：聚簇索引（主键索引）、二级索引（辅助索引）</li><li><code>字段特性</code>分类：主键索引、唯一索引、普通索引、前缀索引</li><li><code>字段个数</code>分类：单列索引、联合索引</li></ul><h3 id="数据结构分类"><a href="#数据结构分类" class="headerlink" title="数据结构分类"></a>数据结构分类</h3><p>从数据结构的角度来看，MySQL 常见索引有 B+tree、Hash、Full-text</p><img src="/blog/2024/09/29/MySQL-%E7%B4%A2%E5%BC%95/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%95%E6%93%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E7%B1%BB.png" class=""><p>InnoDB 在 MySQL 5.5 之后称谓默认引擎， B+tree 索引类型也是 MySQL 存储引擎采用最多的索引类型。<br>在创建表时， InnoDB 存储引擎会根据不同的场景选择不同的列作为索引：</p><ul><li>如果有主键，默认会使用主键作为聚簇索引的索引键(key);</li><li>如果没有主键，就选择第一个不包含<code>NULL</code>值的唯一列作为聚簇索引的索引键(key);</li><li>在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键(key);</li></ul><p>其他索引都属于辅助索引(Secondary Index)，也称为二级索引或非聚簇索引。<br><code>创建的主键索引和二级索引默认使用的是 B+Tree 索引</code>。</p><p>B+Tree 是一个种多叉树，叶子节点才存放数据，非叶子节点只存放索引，而且每个结点里的数据是<code>按主键顺序存档</code>的。每一层父节点的索引值都会出现在下层子结点的索引值种，因此在叶子节点中，包括了所有的索引值信息，<code>并且每一个叶子结点都有两个指针</code>,分别指向<code>下一个叶子结点</code>和<code>上一个叶子结点</code>，形成一个<code>双向链表</code>。</p><p>数据库的<code>索引</code>和<code>数据</code>都是存储在硬盘的，我们可以把读取一个结点当做一次磁盘 I/O 操作。B+Tree 先比与 B 树和二叉树来说，最大的优势在于<code>查询效率很高，因为即使在数据量很大的情况，查询一个数据的磁盘 I/O 依然维持在 3-4次</code>。</p><h4 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h4><p>如果用二级索引查询，会先检查二级索引中的 B+Tree 的索引值，在找到对应叶子节点然后获取的是主键值，然后在通过<code>主键索引的 B+Tree 树</code>找到目标主键值对应的整行数据。这个过程叫<code>回表</code>，也就是说要查 2 个 B+Tree 才能查到数据。</p><h4 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h4><p>特别地，当查询的数据是能在二级索引的 B+Tree 的叶子节点里查询到，这时就不用再去处理主键索引查询。</p><h4 id="InnoDB-默认采用-B-Tree-原因"><a href="#InnoDB-默认采用-B-Tree-原因" class="headerlink" title="InnoDB 默认采用 B+Tree 原因"></a>InnoDB 默认采用 B+Tree 原因</h4><ul><li>B+Tree <code>VS 二叉树</code> 非叶子节点不存在实际的记录数据，仅放索引，数据量相同场景下，这些非叶子节点可以存放更多的索引，所以树的高度可以很好的控制尽可能的小，因此查询底层结点磁盘 I/O 次数更少，查询效率那么就更高</li><li>B+Tree <code>VS B 树</code> 只有叶子结点存放数据，单个结点的数据量可以更小。同时有大量冗余节点（非叶子节点），这些冗余节点让插入、删除的效率都更高</li><li>B+Tree <code>VS Hash</code> 叶子节点之间用链表链接起来，有利于范围查询</li></ul><h3 id="物理存储分类"><a href="#物理存储分类" class="headerlink" title="物理存储分类"></a>物理存储分类</h3><p>从物理存储的角度来看，索引分为聚簇索引（主键索引）、二级索引（辅助索引）。<br>这两个区别：</p><ul><li>主键索引的 B+Tree 叶子节点存放的是实际数据</li><li>二级索引的 B+Tree 的叶子节点存放的都是主键值而不是实际数据，非索引覆盖场景下，存在回表操作，磁盘 I/O 开销更高，查询效率则会更低</li></ul><h3 id="字段特性分类"><a href="#字段特性分类" class="headerlink" title="字段特性分类"></a>字段特性分类</h3><p>从字段特性的角度来看，索引分为主键索引、唯一索引、普通索引、前缀索引。</p><h4 id="主键索引-PRIMARY-KEY"><a href="#主键索引-PRIMARY-KEY" class="headerlink" title="主键索引(PRIMARY KEY)"></a>主键索引(PRIMARY KEY)</h4><p>一张表最多只有一个主键索引，改索引列的值不允许有空值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">\\ 建表时<br><span class="hljs-keyword">PRIMARY</span> <span class="hljs-keyword">KEY</span> (index_column_1)<br></code></pre></td></tr></table></figure><h4 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h4><p>一张表可以有多个唯一索引，索引列的值必须唯一，但允许有空值（数据库将<code>NULL</code>视为<code>缺失值</code>）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">\\ 建表时<br><span class="hljs-keyword">UNIQUE</span> KEY (index_column_1, index_column_2, ...)<br><br>\\ 建表后，创建唯一索引：<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">UNIQUE</span> INDEX index_name<br><span class="hljs-keyword">ON</span> table_name(index_colomun_1, index_column_2, ...)<br></code></pre></td></tr></table></figure><h4 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h4><p>普通索引就是建立在普通字段上的索引，既不要求字段为主键，也不要求字段为 UNIQUE。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">\\ 建表时<br>INDEX(index_column_1, index_column_2, ...)<br><br>\\ 建表后，创建唯一索引：<br><span class="hljs-keyword">CREATE</span> INDEX index_name<br><span class="hljs-keyword">ON</span> table_name(index_colomun_1, index_column_2, ...)<br></code></pre></td></tr></table></figure><h4 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h4><p>前缀索引是指对字符类型字段的前几个字符建立的索引，而不是整个字段上建立的索引。<br>可以建立在字段类型为 char, varchar, binary, varbinary 的列上。<br>使用前缀索引的目的是<code>减少索引占用的存储空间，提升查询效率</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">\\ 建表时<br>INDEX(column_name(length))<br><br>\\ 建表后，创建唯一索引：<br><span class="hljs-keyword">CREATE</span> INDEX index_name<br><span class="hljs-keyword">ON</span> table_name(column_name(length))<br></code></pre></td></tr></table></figure><h3 id="字段个数分类"><a href="#字段个数分类" class="headerlink" title="字段个数分类"></a>字段个数分类</h3><p>从字段个数的角度来看，索引分为单列索引、联合索引（复合索引）。</p><h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><p>通过将多个字段组合成一个索引，该索引就被称为联合索引。</p><p>联合索引的非叶子节点用两个字段的值作为 B+Tree 的 key 值。<br>使用联合索引，存在<code>最左匹配原则</code>，也就是按照最左优先的方式进行索引的匹配。<br>举例联合索引(a,b,c),<code>b和c是全局无序，局部相对有序</code>,如果查询条件最左无a,那么就不满足最左匹配原则，结果就用不到联合索引了。当然利用索引的前提，还需要<code>索引里的 key 是有序的</code>。</p><h5 id="联合索引的范围查询"><a href="#联合索引的范围查询" class="headerlink" title="联合索引的范围查询"></a>联合索引的范围查询</h5><p>特殊情况：并不是查询过程使用了联合索引查询，就代表联合索引中的所有字段都用到了联合索引进行索引查询。这种情况就发生在<code>范围查询</code>。</p><p>联合索引的最左匹配原则一直向右匹配，直到遇到<code>范围查询</code>就会停止匹配。<code>也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引</code>。</p><p>可以在执行计划中的<code>key_len</code>来辨别联合索引查询过程中使用了多少个字段。（根据不同字段类型占用的字节数来比较）。<br>如下的特殊前缀匹配强调说明：</p><ul><li>区别 &gt;=、&lt;= 与 &gt;、&lt; 的区别，前者不会中止联合索引的效果</li><li>BETWEEN… AND… 在不同的数据库之下处理有差异，如果包含 = 的情况，则一样不会中止联合索引的效果</li><li>like ‘x%’ 不会中止联合索引效率。（区别于 %x，这个效率会更低）</li></ul><h5 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h5><p>对于联合索引<code>(a,b)</code>，在执行<code>select * from table where a&gt;1 and b=2</code>语句的时候，只有 a 字段用到索引，那在联合索引的 B+Tree 找到第一个满足条件的主键值（a = 2）后，还需要判断其他条件是否满足（看 b 是否等于 2），也就是<code>在联合索引遍历过程中，对联合索引中包含的字段继续做后续判断，直接过滤掉不满足条件的记录，减少回表次数</code>。（MySQL 5.6 之后引入）</p><p>当你查询的执行计划里，Extra 字段出现<code>Using index condition</code>，那么说明使用了索引下推的优化。</p><h5 id="索引区分度"><a href="#索引区分度" class="headerlink" title="索引区分度"></a>索引区分度</h5><p>建立联合索引时的字段顺序，对索引效率也有很大影响。越靠前的字段被用于索引过滤的概率越高，实际开发工作中<code>建立联合索引时，要把区分度大的字段盘在前面</code>。如<code>UUID</code>字段。</p><p>区分度就是某个字段 column 不同值的个数除以表总行数，计算公式如下：<br><code>区分度 = distinct(column) / count(*)</code></p><h2 id="创建索引的场景"><a href="#创建索引的场景" class="headerlink" title="创建索引的场景"></a>创建索引的场景</h2><p>索引的最大好处就是<code>提高查询速度</code>,但是也有缺点：</p><ul><li>需要占用物理空间，数量越大，占用空间越大</li><li>创建索引和维护索引需要耗费时间，这种时间还会伴随着数据量的增加而增大</li><li>降低表的 CRUD 效率，因为每次 CRUD 索引，B+Tree 为了维护索引有序性，都需要进行动态调整</li></ul><h3 id="什么时候适用索引？"><a href="#什么时候适用索引？" class="headerlink" title="什么时候适用索引？"></a>什么时候适用索引？</h3><ul><li>字段有唯一性限制，比如商品编码、用户 uuid</li><li>经常用于<code>WHERE</code>查询条件的字段，如果查询条件不是一个列，可以建立联合索引</li><li>经常用于<code>GROUP BY</code> 和 <code>ORDER BY</code>的字段，这样在查询的时候就不需要再去做一次排序(filesort)了，因为简历索引之后 B+Tree 的叶子节点中记录都是有序排列好的</li></ul><h3 id="什么时候不需要创建索引？"><a href="#什么时候不需要创建索引？" class="headerlink" title="什么时候不需要创建索引？"></a>什么时候不需要创建索引？</h3><ul><li>存在大量重复数据，不需要创建索引，比如性别字段</li><li>表数据太少的时候，不需要创建索引</li><li><code>WHERE、GROUP BY、ORDER BY</code> 里用不到的字段，就不需要浪费物理空间去创建索引</li><li>经常更新的字段，比如用户积分或账户余额，就不需要创建索引，因为索引字段频繁修改，由于 B+Tree 会自适应维护有序性，那么就需要频繁的重建索引，这个过程是会大大影响数据库的性能</li></ul><h3 id="有什么优化索引的方法？"><a href="#有什么优化索引的方法？" class="headerlink" title="有什么优化索引的方法？"></a>有什么优化索引的方法？</h3><ul><li>前缀索引优化</li><li>覆盖索引优化</li><li>主键索引最好是自增的</li><li>索引最好是 NOT NULL</li><li>防止索引失效</li></ul><h4 id="前缀索引优化"><a href="#前缀索引优化" class="headerlink" title="前缀索引优化"></a>前缀索引优化</h4><p>在一些大字符串的字段作索引时，使用前缀索引时为了减小索引字段大小。<br>但前缀索引也有一定局限性：</p><ul><li>order by 无法使用前缀索引</li><li>无法把前缀索引用作覆盖索引</li></ul><h4 id="覆盖索引优化"><a href="#覆盖索引优化" class="headerlink" title="覆盖索引优化"></a>覆盖索引优化</h4><p>覆盖索引指 SQL 中 query 的所有字段，在索引 B+Tree 的叶子节点上都能找得到的那些索引，从二级索引中查询得到的记录，而不需要通过聚簇索引查询获得，避免回表的操作。好处就是不需要查询包含整行记录的所有信息。</p><h4 id="主键索引最好是自增的"><a href="#主键索引最好是自增的" class="headerlink" title="主键索引最好是自增的"></a>主键索引最好是自增的</h4><p>磁盘读写的最小单位是扇区，扇区的大小只有 512B 大小，操作系统一次会读写多个扇区，所以操作系统的最小读写单位是块（Block）。Linux 中的块大小为 4KB，也就是一次磁盘  I/O 操作会直接读写 8 个扇区</p><p>如果非自增主键，由于每次插入主键的索引值都是随机的，因此每次插入新的数据时，可能会插入到现有（或已满的）数据页中某个位置，这不得不移动其他数据来满足新数据的插入，甚至需要从一个页复制数据到另一个页，通常将这种情况称为<code>页分裂</code>。页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率。</p><h4 id="防止索引失效"><a href="#防止索引失效" class="headerlink" title="防止索引失效"></a>防止索引失效</h4><p>简单总结索引失效的情况：</p><ul><li>左<code>like %x</code>或者左右<code>like %x%</code>模糊匹配</li><li>查询条件中对索引列做了计算、函数、类型转换</li><li>未遵循最左匹配原则</li><li>在<code>WHERE</code>字句中<code>OR</code>的前后条件列有一个不是索引列</li></ul><p>实际场景中，可能出现其他的索引失效，这时就需要查看执行计划，其参数有：</p><ul><li>possible_keys：可能用到的索引</li><li>key：实际用的所以，NULL 说明没有使用索引</li><li>key_len：索引的长度</li><li>rows：扫描的数据行数</li><li>type：扫描类型，执行效率低-&gt;高依次为，其中的（ALL 和 index 尽量避免）<ul><li>ALL 全表扫描</li><li>index 全索引扫描</li><li>range 索引范围扫描</li><li>ref 非唯一索引扫描</li><li>eq_ref 唯一索引扫描</li><li>const 结果只有一条的主键或唯一索引扫描</li></ul></li></ul><p>除了关注<code>Type</code>也需要关注<code>extra</code>显示的结果：</p><ul><li>❌ Using filesort<br>使用 group by 操作且无法使用索引</li><li>❌ Using temporary<br>使用 order by 或 group by 过程中保存中间结果利用了临时表</li><li>✅ Using index<br>所需数据使用了覆盖索引，避免回表操作，效率高</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL 索引</tag>
      
      <tag>索引</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 基础</title>
    <link href="/blog/2024/09/28/MySQL-%E5%9F%BA%E7%A1%80/"/>
    <url>/blog/2024/09/28/MySQL-%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="知识总览"><a href="#知识总览" class="headerlink" title="知识总览"></a>知识总览</h2><p>学习 SQL 的时候，肯定第一先学到的就是 select 查询语句，那么这个查询语句背后的实现又是如何呢？</p><h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><figure class="highlight sql"><figcaption><span>执行一条 select 查询语句</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> product <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>上述 SQL 查询语句例子在 MySQL 内部发生了什么？带着这个问题我们继续往下看，先来一个上帝视角图，去认识其内部每一个”零件”具体是负责做什么的。</p><img src="/blog/2024/09/28/MySQL-%E5%9F%BA%E7%A1%80/MySQL-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.png" class="" title="执行一条查询语句的流程图"><p>可以看到， MySQL 的架构共分为两层：<code>Server 层</code> 和 <code>存储引擎层</code></p><div class="note note-default">            <ul><li><p><code>Server 层负责建立连接、分析和执行 SQL</code>。MySQL 大多数的核心功能模块都在这实现，主要包括连接器、查询缓存、解析器、预处理器、优化器、执行器等。另外，所有的内置函数（如日期、时间、数学和加密函数等）和所有跨存储引擎的功能（如存储过程、触发器、视图等），都在 Server 层实现。</p></li><li><p><code>存储引擎层负责数据的存储和提取</code>。支持 InnoDB、MyISAM、Memory 等多个存储引擎，不同的存储引擎共用一个 Server 层。现在最常用的存储引擎（默认）是 InnoDB。我们常说的索引数据结构，就是有存储引擎层实现的，不同的存储引擎支持的索引类型也不相同，比如 InnoDB 支持索引类型（默认）是 B+ 树，也就是说在数据表中创建的主键索引和二级索引默认使用的是 B+ 树索引。</p></li></ul>          </div><p>好了，现在对 Server 层和存储引擎层有了一个简单的认识后，接下来，就详细俺看每个功能模块的作用。</p><h2 id="第一步：连接器"><a href="#第一步：连接器" class="headerlink" title="第一步：连接器"></a>第一步：连接器</h2><p>首先，需要连接 MySQL 服务，然后才能执行 SQL 语句，大部分情况都是使用这样的命令连接：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysql -h&lt;$ip&gt; -u&lt;$user&gt; -p<br></code></pre></td></tr></table></figure><p>连接的过程需要先经过 TCP 三次握手，因为 MySQL 是基于 TCP 协议进行传输的。如果用户名及密码都没有问题，连接器就会获取该用户的权限，然后保存起来，后续该用户在此丽娜姐里的任何操作，都会基于链接开始时读到的权限进行权限逻辑的判断。</p><p>所以，如果一个用户建立连接后，即使管理员中途修改了该用户的权限，也不会影响已经存在的权限。要使其修改生效，则只有用户重新建立连接才行。</p><div class="note note-warning">            <p>如何查看 MySQL 服务被多少个客户端连接了？</p>          </div><p>如果想知道当前 MySQL 服务被多少个客户端连接了，你可以执行<code>show processlist</code>命令查看。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">show</span> processlist;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+-----------------+-----------+------+---------+------+------------------------+------------------+</span><br><span class="hljs-operator">|</span> Id <span class="hljs-operator">|</span> <span class="hljs-keyword">User</span>            <span class="hljs-operator">|</span> Host      <span class="hljs-operator">|</span> db   <span class="hljs-operator">|</span> Command <span class="hljs-operator">|</span> <span class="hljs-type">Time</span> <span class="hljs-operator">|</span> State                  <span class="hljs-operator">|</span> Info             <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-----------------+-----------+------+---------+------+------------------------+------------------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">5</span> <span class="hljs-operator">|</span> event_scheduler <span class="hljs-operator">|</span> localhost <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span> Daemon  <span class="hljs-operator">|</span> <span class="hljs-number">1322</span> <span class="hljs-operator">|</span> Waiting <span class="hljs-keyword">on</span> <span class="hljs-keyword">empty</span> queue <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>             <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">12</span> <span class="hljs-operator">|</span> root            <span class="hljs-operator">|</span> localhost <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span> Sleep   <span class="hljs-operator">|</span>   <span class="hljs-number">48</span> <span class="hljs-operator">|</span>                        <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>             <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">13</span> <span class="hljs-operator">|</span> root            <span class="hljs-operator">|</span> localhost <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span> Query   <span class="hljs-operator">|</span>    <span class="hljs-number">0</span> <span class="hljs-operator">|</span> init                   <span class="hljs-operator">|</span> <span class="hljs-keyword">show</span> processlist <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-----------------+-----------+------+---------+------+------------------------+------------------+</span><br><span class="hljs-number">3</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span>, <span class="hljs-number">1</span> warning (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>空闲连接会一直占用着吗？</p>          </div><p>当然不是了，MySQL 定义了空闲连接的最大空闲时长，由<code>wait_timeout</code>参数控制，默认是 8 小时（28880 秒），如果空闲连接超过了此时间，连接器就会自动将它断开。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> &quot;wait_timeout&quot;;<br><span class="hljs-operator">+</span><span class="hljs-comment">---------------+-------+</span><br><span class="hljs-operator">|</span> Variable_name <span class="hljs-operator">|</span> <span class="hljs-keyword">Value</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------------+-------+</span><br><span class="hljs-operator">|</span> wait_timeout  <span class="hljs-operator">|</span> <span class="hljs-number">28800</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------------+-------+</span><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.01</span> sec)<br></code></pre></td></tr></table></figure><p>当然也可以手动断开空闲的连接，使用<code>kill connection &lt;$id&gt;</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">show</span> processlist;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+-----------------+-----------+------+---------+------+------------------------+------------------+</span><br><span class="hljs-operator">|</span> Id <span class="hljs-operator">|</span> <span class="hljs-keyword">User</span>            <span class="hljs-operator">|</span> Host      <span class="hljs-operator">|</span> db   <span class="hljs-operator">|</span> Command <span class="hljs-operator">|</span> <span class="hljs-type">Time</span> <span class="hljs-operator">|</span> State                  <span class="hljs-operator">|</span> Info             <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-----------------+-----------+------+---------+------+------------------------+------------------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">5</span> <span class="hljs-operator">|</span> event_scheduler <span class="hljs-operator">|</span> localhost <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span> Daemon  <span class="hljs-operator">|</span> <span class="hljs-number">1465</span> <span class="hljs-operator">|</span> Waiting <span class="hljs-keyword">on</span> <span class="hljs-keyword">empty</span> queue <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>             <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">14</span> <span class="hljs-operator">|</span> root            <span class="hljs-operator">|</span> localhost <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span> Query   <span class="hljs-operator">|</span>    <span class="hljs-number">0</span> <span class="hljs-operator">|</span> init                   <span class="hljs-operator">|</span> <span class="hljs-keyword">show</span> processlist <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">15</span> <span class="hljs-operator">|</span> root            <span class="hljs-operator">|</span> localhost <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span> Sleep   <span class="hljs-operator">|</span>    <span class="hljs-number">6</span> <span class="hljs-operator">|</span>                        <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>             <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-----------------+-----------+------+---------+------+------------------------+------------------+</span><br><span class="hljs-number">3</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span>, <span class="hljs-number">1</span> warning (<span class="hljs-number">0.00</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span> kill connection <span class="hljs-number">15</span>;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>MySQL 的连接数有限制吗？</p>          </div><p>MySQL 服务支持的最大链接数由 max_connections 参数控制，比如我的 MySQL 服务默认是 151 个，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> &quot;max_connections&quot;;<br><span class="hljs-operator">+</span><span class="hljs-comment">-----------------+-------+</span><br><span class="hljs-operator">|</span> Variable_name   <span class="hljs-operator">|</span> <span class="hljs-keyword">Value</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-----------------+-------+</span><br><span class="hljs-operator">|</span> max_connections <span class="hljs-operator">|</span> <span class="hljs-number">151</span>   <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-----------------+-------+</span><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><p>MySQL 的连接也跟 HTTP 一样，有短连接和长连接的概念，区别如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span> 短连接<br>连接 mysql 服务（TCP 三次握手）<br>执行 <span class="hljs-keyword">sql</span><br>断开 mysql 服务（TCP 四次挥手）<br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span> 长连接<br>连接 mysql 服务（TCP 三次握手）<br>执行 <span class="hljs-keyword">sql</span><br>执行 <span class="hljs-keyword">sql</span><br>执行 <span class="hljs-keyword">sql</span><br>执行 <span class="hljs-keyword">sql</span><br>...<br>断开 mysql 服务（TCP 四次挥手）<br></code></pre></td></tr></table></figure><p>可以看到，使用长连接的好处就是可以减少建立连接和断开连接时间的 IO 开销，故推荐使用长连接。</p><p>但是，使用长连接后可能会占用内存增多，因为 MySQL 在执行查询过程中临时使用内存管理连接对象，这些连接对象资源只有在连接断开时才会释放。<br>如果长连接累积到一定程度，将导致 MySQL 服务占用内存过大，会面临被系统强制中断的风险，这样会发生 MySQL 服务异常重启的现象。</p><div class="note note-warning">            <p>怎样解决长连接占用内存的问题？</p>          </div><p>两种解决方案：<code>定期断开长连接</code>和<code>客户端主动重置连接</code>。</p><p>第一种，<code>定期断开长连接</code>。既然断开连接后，就会释放连接占用的内存资源，那么我们可以定期断开长连接。<br>第二种，<code>客户端主动重置连接</code>。当客户端执行了一个很大的操作后，在代码里调用（仅存在于 MySQL<code>5.7</code>版本）内置函数 mysql_reset_connection() 来重置连接，达到释放内存的效果，这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚创建完时的状态。</p><p>至此，连接器的工作做完了，总结如下：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">* </span>与客户端进行 TCP 三次握手建立连接；<br><span class="hljs-bullet">* </span>校验客户端的用户名和密码，若校验失败则会报错；<br><span class="hljs-bullet">* </span>校验成功后，获取用户权限，然后后面的权限逻辑判断都基于此时读取到的权限。<br></code></pre></td></tr></table></figure><h2 id="第二步：查询缓存"><a href="#第二步：查询缓存" class="headerlink" title="第二步：查询缓存"></a>第二步：查询缓存</h2><p>连接器的工作完成后，客户端就可以向 MySQL 服务发送 SQL 语句了，MySQL 服务收到 SQL y语句后，就会解析出 SQL 语句的第一个字段，看看是什么类型的语句。</p><p>如果 SQL 是查询语句（<code>select</code> 语句），MySQL 就会先去查询缓存（Query Cache）里查找缓存数据，看看之前有没有执行过这一条命令，这个查询缓存时以 key-value 形式保存在内存中的，key 为 SQL 查询语句，value 为 SQL 语句查询的结果。</p><p>如果查询的语句命中查询缓存，那么就会直接返回 value 给客户端。否则，就继续往下执行，等执行完后，查询的结果就会被存入查询缓存中。</p><p>这么看，查询缓存还挺有用，但<code>对于更新频繁的表，其实查询缓存很鸡肋</code>。所以在 MySQL 8.0 版本直接将查询缓存删掉了。对于此前版本，若要关闭查询缓存可以执行命令将参数<code>query_cache_type</code>设置成DEMAND。</p><div class="note note-success">            <p>TIP<br>这里说的查询缓存时 server 层的，并不是 InnoDB 存储引擎中的 buffer pool。</p>          </div><h2 id="第三部：解析-SQL"><a href="#第三部：解析-SQL" class="headerlink" title="第三部：解析 SQL"></a>第三部：解析 SQL</h2><p>在正式执行 SQL 查询语句之前，MySQL 会先对 SQL 语句做解析，这个工作交由<code>解析器</code>来完成。</p><h3 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a>解析器</h3><p>解析器会做 <code>词法分析</code> 和 <code>语法分析</code> 这两件事：<br>第一件事，<code>词法分析</code>。MySQL 会根据你输入的字符串识别出关键字出来，例如，SQL 语句 <code>select username from userinfo</code>，在分析之后，会得到 4 个 token，其中有 2 个 keyword，分别是<code>select</code>和<code>from</code>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">+</span><span class="hljs-comment">---------+----------+-------+---------+</span><br><span class="hljs-operator">|</span>  关键字  <span class="hljs-operator">|</span> 非关键字  <span class="hljs-operator">|</span> 关键字 <span class="hljs-operator">|</span> 非关键字  <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------+----------+-------+----------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-keyword">select</span> <span class="hljs-operator">|</span> username <span class="hljs-operator">|</span> <span class="hljs-keyword">from</span>  <span class="hljs-operator">|</span> userinfo <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------+----------+-------+----------+</span><br></code></pre></td></tr></table></figure><p>第二件事，<code>语法分析</code>。分句词法分析的结果，语法解析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL yu语法，如果没问题就会构建出 SQL 语法树，这样方便后续执行流程工作模块获取 SQL 类型、表名、字段名、where 条件等等。</p><img src="/blog/2024/09/28/MySQL-%E5%9F%BA%E7%A1%80/MySQL-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90.png" class="" title="MySQL-语法分析"><p>那么通常情况下，表不存在或者字段不存在，是在解析器做的吗？</p><h2 id="第四部：执行-SQL"><a href="#第四部：执行-SQL" class="headerlink" title="第四部：执行 SQL"></a>第四部：执行 SQL</h2><p>经过解析器后，接着就要进入 SQL 查询语句的流程了，每条<code>select</code>查询语句流程重要可以分为下面三阶段：</p><ul><li>prepare，预处理</li><li>optimize，优化</li><li>execute，执行<h3 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h3>预处理阶段做了什么事情？</li><li>检查 SQL 查询语句中的表或字段是否存在；</li><li>将 select * 中的 * 符号，扩展为表上的所有数据项名称，即列。<h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3>经过预处理阶段后，还需要为 SQL 查询语句先指定一个执行计划，这个工作交由优化器来完成。<br><code>优化器主要负责将 SQL 查询语句的执行方案确定下来</code>，比如在表里有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引。<br>当然，我们本次的示例查询语句<code>select * from product where id=1</code>很简单，就是选择使用主键索引。<br>要想知道优化器选择了哪个索引，我们可以在查询语句前面加个<code>explain</code>命令，这样就会输出这条 SQL 语句的执行计划，然后执行计划中的<code>key</code>就表示执行过程中使用了哪个索引，比如下图的<code>key</code>为<code>PRIMARY</code>就是使用了主键索引，这样的执行效率最优。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> orders <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">2</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+--------+------------+-------+---------------+-----------+---------+-------+------+----------+-------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> select_type <span class="hljs-operator">|</span> <span class="hljs-keyword">table</span>  <span class="hljs-operator">|</span> partitions <span class="hljs-operator">|</span> type  <span class="hljs-operator">|</span> possible_keys <span class="hljs-operator">|</span> `key`     <span class="hljs-operator">|</span> key_len <span class="hljs-operator">|</span> <span class="hljs-keyword">ref</span>   <span class="hljs-operator">|</span> <span class="hljs-keyword">rows</span> <span class="hljs-operator">|</span> filtered <span class="hljs-operator">|</span> Extra <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+--------+------------+-------+---------------+-----------+---------+-------+------+----------+-------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> SIMPLE      <span class="hljs-operator">|</span> orders <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>       <span class="hljs-operator">|</span> const <span class="hljs-operator">|</span> <span class="hljs-keyword">PRIMARY</span>       <span class="hljs-operator">|</span> `<span class="hljs-keyword">PRIMARY</span>` <span class="hljs-operator">|</span> <span class="hljs-number">4</span>       <span class="hljs-operator">|</span> const <span class="hljs-operator">|</span>    <span class="hljs-number">1</span> <span class="hljs-operator">|</span>   <span class="hljs-number">100.00</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>  <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+--------+------------+-------+---------------+-----------+---------+-------+------+----------+-------+</span><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span>, <span class="hljs-number">1</span> warning (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><p>如果查询语句的执行计划里的<code>key</code>为<code>null</code>说明没有使用索引，俺就会全表扫描（<code>type=ALL</code>）,这样执行效率最低，如下示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> orders <span class="hljs-keyword">where</span> product_id<span class="hljs-operator">=</span><span class="hljs-number">2</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+--------+------------+--------+---------------+--------+---------+------+------+----------+-------------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> select_type <span class="hljs-operator">|</span> <span class="hljs-keyword">table</span>  <span class="hljs-operator">|</span> partitions <span class="hljs-operator">|</span> `type` <span class="hljs-operator">|</span> possible_keys <span class="hljs-operator">|</span> `key`  <span class="hljs-operator">|</span> key_len <span class="hljs-operator">|</span> <span class="hljs-keyword">ref</span>  <span class="hljs-operator">|</span> <span class="hljs-keyword">rows</span> <span class="hljs-operator">|</span> filtered <span class="hljs-operator">|</span> Extra       <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+--------+------------+--------+---------------+--------+---------+------+------+----------+-------------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> SIMPLE      <span class="hljs-operator">|</span> orders <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>       <span class="hljs-operator">|</span> `<span class="hljs-keyword">ALL</span>`  <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>          <span class="hljs-operator">|</span> `<span class="hljs-keyword">NULL</span>` <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>    <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span>    <span class="hljs-number">5</span> <span class="hljs-operator">|</span>    <span class="hljs-number">20.00</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">Using</span> <span class="hljs-keyword">where</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+--------+------------+--------+---------------+--------+---------+------+------+----------+-------------+</span><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span>, <span class="hljs-number">1</span> warning (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><p>现在给 products 表的 name 字段设置为普通索引（二级索引）：<br>这样就会出现查询语句的结果既可以使用主键索引，也可以使用普通索引，但是执行的效率会不用，这时，就需要<code>优化器</code>来决定使用哪个索引了。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> powerx.products <span class="hljs-keyword">where</span> id <span class="hljs-operator">&gt;</span> <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> name <span class="hljs-keyword">like</span> &quot;t%&quot;;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+----------+------------+-------+-----------------------+-------------+---------+------+------+----------+----------------------------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> select_type <span class="hljs-operator">|</span> <span class="hljs-keyword">table</span>    <span class="hljs-operator">|</span> partitions <span class="hljs-operator">|</span> type  <span class="hljs-operator">|</span> `possible_keys`       <span class="hljs-operator">|</span> `key`       <span class="hljs-operator">|</span> key_len <span class="hljs-operator">|</span> <span class="hljs-keyword">ref</span>  <span class="hljs-operator">|</span> <span class="hljs-keyword">rows</span> <span class="hljs-operator">|</span> filtered <span class="hljs-operator">|</span> `Extra`                    <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+----------+------------+-------+-----------------------+-------------+---------+------+------+----------+----------------------------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> SIMPLE      <span class="hljs-operator">|</span> products <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>       <span class="hljs-operator">|</span> <span class="hljs-keyword">range</span> <span class="hljs-operator">|</span> `<span class="hljs-keyword">PRIMARY</span>`,`idex_name` <span class="hljs-operator">|</span> `idex_name` <span class="hljs-operator">|</span> <span class="hljs-number">207</span>     <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span>    <span class="hljs-number">1</span> <span class="hljs-operator">|</span>    <span class="hljs-number">60.00</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">Using</span> <span class="hljs-keyword">where</span>; `<span class="hljs-keyword">Using</span> index` <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+----------+------------+-------+-----------------------+-------------+---------+------+------+----------+----------------------------+</span><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span>, <span class="hljs-number">1</span> warning (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><p>很显然这条查询语句就是<code>覆盖索引</code>，直接在二级索引就能查找到结果（因为二级索引的B+树的叶子结点的数据存储的就是主键值），就没必要再主键索引查找了，因为查询成本对比之中，主键索引的B+树 &gt; 查询二级索引的B+树，所以优化器基于查询成本的考量，会选择查询代价小的二级索引。</p><h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><p>经历完优化器后，就确定了执行方案，接下来 MySQL 就开始执行语句了，这个工作由<code>执行器</code>完成。在执行的过程中，执行器就会和存储引擎交互，交互是以<code>记录</code>为单位的。</p><p>接下来，用三种方式执行过程，来了解执行器和存储引擎的交互细节。</p><ul><li>主键索引查询</li><li>全表扫描</li><li>索引下推</li></ul><h4 id="主键索引查询"><a href="#主键索引查询" class="headerlink" title="主键索引查询"></a>主键索引查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> products <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>这条查询语句用到了主键索引，而且是等值查询，同时主键 id 是唯一，不会有 id 相同的记录，所以优化器决定选用访问类型为<code>const</code>进行查询，也就是使用主键索引查询一条记录，那么执行器与存储引擎的交互细节如下：</p><img src="/blog/2024/09/28/MySQL-%E5%9F%BA%E7%A1%80/%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E6%9F%A5%E8%AF%A2.png" class=""><h4 id="全表扫描"><a href="#全表扫描" class="headerlink" title="全表扫描"></a>全表扫描</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> products <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;product_01&#x27;</span>;<br></code></pre></td></tr></table></figure><p>这样的查询语句的查询条件没有用到索引，所以优化器决定选用访问类型为<code>ALL</code>进行查询,这时候执行器与存储引擎的执行流程是这样的：</p><img src="/blog/2024/09/28/MySQL-%E5%9F%BA%E7%A1%80/%E5%85%A8%E8%A1%A8%E6%89%AB%E6%8F%8F.png" class=""><h4 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> powerx.users <span class="hljs-keyword">where</span> username <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;user%&#x27;</span> <span class="hljs-keyword">and</span> email <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;user2@example.com&#x27;</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+-------+------------+-------+--------------------+--------------------+---------+------+------+----------+-----------------------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> select_type <span class="hljs-operator">|</span> <span class="hljs-keyword">table</span> <span class="hljs-operator">|</span> partitions <span class="hljs-operator">|</span> type  <span class="hljs-operator">|</span> possible_keys      <span class="hljs-operator">|</span> key                <span class="hljs-operator">|</span> key_len <span class="hljs-operator">|</span> <span class="hljs-keyword">ref</span>  <span class="hljs-operator">|</span> <span class="hljs-keyword">rows</span> <span class="hljs-operator">|</span> filtered <span class="hljs-operator">|</span> Extra                 <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+-------+------------+-------+--------------------+--------------------+---------+------+------+----------+-----------------------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> SIMPLE      <span class="hljs-operator">|</span> users <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>       <span class="hljs-operator">|</span> <span class="hljs-keyword">range</span> <span class="hljs-operator">|</span> idx_username_email <span class="hljs-operator">|</span> idx_username_email <span class="hljs-operator">|</span> <span class="hljs-number">404</span>     <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span>    <span class="hljs-number">5</span> <span class="hljs-operator">|</span>    <span class="hljs-number">20.00</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">Using</span> index <span class="hljs-keyword">condition</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+-------+------------+-------+--------------------+--------------------+---------+------+------+----------+-----------------------+</span><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span>, <span class="hljs-number">1</span> warning (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><p>联合索引当遇到范围查询（&gt;,&lt;）就会停止匹配，也就是<code>username</code>字段能用到联合索引，但是<code>email</code>字段则无法利用到索引。（因为范围查询之后的字段可能存在无序情况，具体分析原因见后面章节）</p><img src="/blog/2024/09/28/MySQL-%E5%9F%BA%E7%A1%80/%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8.png" class=""><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>执行一条 SQL 查询语句，期间发生了什么?</p><ul><li>连接器：建立连接，管理连接、校验用户身份；</li><li>查询缓存：查询语句若命中查询缓存则直接返回，否则继续往下执行。此模块在 8.0 版本 Deprecated；</li><li>解析 SQL：通过解析器对 SQL 查询语句进行词法分析、语法分析、构建语法树，方便后续模块读取表名、字段和语句类型；</li><li>执行 SQL：执行分三阶段：<ul><li>预处理阶段：检查表或字段是否存在，将 select * 的 * 符号扩展为表上所有列；</li><li>优化阶段：基于查询成本考量，选择查询成本最小的执行计划；</li><li>执行阶段：执行 SQL 查询语句，从存储引擎读取记录，返回客户端</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL 基础</tag>
      
      <tag>基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统-中断和异常</title>
    <link href="/blog/2021/03/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8/"/>
    <url>/blog/2021/03/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8/</url>
    
    <content type="html"><![CDATA[<h2 id="知识总览"><a href="#知识总览" class="headerlink" title="知识总览"></a>知识总览</h2><img src="/blog/2021/03/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9F%A5%E8%AF%86%E6%80%BB%E8%A7%88.png" class="" title="操作系统-中断和异常知识总览"><h2 id="中断机制的诞生"><a href="#中断机制的诞生" class="headerlink" title="中断机制的诞生"></a>中断机制的诞生</h2><p><code>背景</code>：多道处理技术之前，各个程序只能串行，导致 CPU 大部分时间处理空转等待 I/O，效率低</p><p>解决方案：为了解决上述问题，人们发明了操作系统(作为计算机的管理者)，引入中断机制，实现多道程序并发执行</p><p><code>本质</code>：<code>发生中断</code>就意味着<code>需要操作系统介入开展管理资源调度工作</code></p><h2 id="中断的概念和作用"><a href="#中断的概念和作用" class="headerlink" title="中断的概念和作用"></a>中断的概念和作用</h2><p>先来看看一个多道程序技术中中断的工作流程示例：</p><img src="/blog/2021/03/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%B8%AD%E6%96%AD%E5%B7%A5%E4%BD%9C%E7%A4%BA%E4%BE%8B.png" class="" title="操作系统-多道程序的中断工作示例"><p><code>总结</code>:<br>1、当中断发生时，CPU 立即进程<code>核心态</code><br>2、当中断发生后，当前进程暂停执行，同时由操作系统内核对中断信号进程处理<br>3、中断让操作系统获得控制权并进而开展资源调度工作，最后才能实现多道程序并发执行。</p><div class="note note-default">            <p>问：用户态、核心态之间的切换如何实现？</p><p><code>用户态 --&gt; 核心态</code>：只能通过<code>中断</code>实现<br><code>核心态 --&gt; 用户态</code>：可在<code>内核程序</code>或<code>应用程序的系统调用（归根到底还是内核程序）</code>中执行<code>特权指令</code>，对 PSW 进行设置</p>          </div><h1 id="中断的分类"><a href="#中断的分类" class="headerlink" title="中断的分类"></a>中断的分类</h1><div class="note note-default">            <p><code>内中断</code>：信号来源于 CPU 内部，与程序内容相关</p><ul><li>自愿中断–指令中断，如系统调用（trap 指令）</li><li>强迫中断<ul><li>硬件故障，如硬盘缺页</li><li>软件中断，如整数除 0</li></ul></li></ul><p><code>外中断</code>：信号来源于 CPU 外部，与程序内容无关</p><ul><li>外设中断，如 I/O 操作完成发出的中断信号</li><li>人工干预，如用户强行终止进程</li></ul>          </div><h1 id="外中断的处理过程"><a href="#外中断的处理过程" class="headerlink" title="外中断的处理过程"></a>外中断的处理过程</h1>]]></content>
    
    
    <categories>
      
      <category>中断</category>
      
    </categories>
    
    
    <tags>
      
      <tag>中断</tag>
      
      <tag>异常</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统-运行机制和体系结构</title>
    <link href="/blog/2021/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E5%92%8C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    <url>/blog/2021/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E5%92%8C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h2 id="知识总览"><a href="#知识总览" class="headerlink" title="知识总览"></a>知识总览</h2><img src="/blog/2021/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E5%92%8C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E5%92%8C%E4%BD%93%E7%B3%BB%E6%80%BB%E8%A7%88.png" class="" title="操作系统-运行机制和体系总览"><h2 id="什么是指令？"><a href="#什么是指令？" class="headerlink" title="什么是指令？"></a>什么是指令？</h2><p><code>CPU</code> 能识别并执行的最基本命令。</p><p>两种指令：</p><div class="note note-default">            <p>特权指令：如内存清零指令</p><p>非特权指令：如普通的运算指令</p>          </div><h2 id="CPU-如何判断当前是否可以执行特权指令？"><a href="#CPU-如何判断当前是否可以执行特权指令？" class="headerlink" title="CPU 如何判断当前是否可以执行特权指令？"></a>CPU 如何判断当前是否可以执行特权指令？</h2><p>用程序状态字寄存器中的<code>程序状态字</code>（<code>PSW</code>, Program Status Word）来标识当前处理器处于什么状态。如 <code>0 为用户态</code>，<code>1 为核心态</code>。</p><p>两种状态：</p><div class="note note-default">            <p>核心态（管态）：特权和非特权指令均可执行</p><p>用户态（目态）：此时 CPU 只能执行非特权指令</p>          </div><p>两种程序，内核程序和应用程序。</p><h2 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h2><p><code>内核</code>是计算机上配置的底层<code>软件</code>，是操作系统最基本、核心的部分。</p><img src="/blog/2021/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E5%92%8C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E6%A0%B8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" class="" title="操作系统-内核层次结构"><div class="note note-default">            <p>实现操作系统内核功能的那些程序就是<code>内核程序</code></p>          </div><h2 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2><p>根据<code>内核</code>结构的不同，可延伸出连两种体系结构：<code>微内核</code>、<code>大内核</code></p><div class="note note-default">            <p><code>微内核</code>：只把最基本的功能保留（如时钟管理、中断管理和原语），结构清晰方便维护，但频繁在管态和目态切换所以性能低</p><p><code>大内核</code>：除了保留微内核的基本功能，还留有进程管理、处理器管理和设备管理，结构复杂不易于维护，但性能较高</p>          </div>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>运行机制</category>
      
      <category>中断处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>中断</tag>
      
      <tag>操作系统</tag>
      
      <tag>运行机制</tag>
      
      <tag>体系结构</tag>
      
      <tag>指令</tag>
      
      <tag>内核</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统-发展和分类</title>
    <link href="/blog/2021/03/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%8F%91%E5%B1%95%E5%92%8C%E5%88%86%E7%B1%BB/"/>
    <url>/blog/2021/03/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%8F%91%E5%B1%95%E5%92%8C%E5%88%86%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="知识总览"><a href="#知识总览" class="headerlink" title="知识总览"></a>知识总览</h2><div class="note note-success">            <ul><li>操作系统的分类</li></ul>          </div><h2 id="手工操作阶段"><a href="#手工操作阶段" class="headerlink" title="手工操作阶段"></a>手工操作阶段</h2><div class="note note-default">            <p>主要缺点：用户独占全机、人机速度矛盾导致资源利用率低下</p>          </div><h2 id="批处理阶段–单道批处理系统"><a href="#批处理阶段–单道批处理系统" class="headerlink" title="批处理阶段–单道批处理系统"></a>批处理阶段–单道批处理系统</h2><p>引入脱机输入/输出技术（使用磁带完成），并<code>监督程序（操作系统雏形）</code>负责控制作业的输入、输出</p><div class="note note-default">            <p>主要优点：缓解人机速度矛盾，资源利用率提升。</p><p>主要缺点：<code>内存中只能有一道程序执行</code>，只有该程序运行结束之后才能进入下一道程序。<code>CPU 有大量的时间是在空闲等待 I/O 完成</code>，资源利用率依然很低。</p>          </div><h2 id="批处理阶段–多道批处理系统"><a href="#批处理阶段–多道批处理系统" class="headerlink" title="批处理阶段–多道批处理系统"></a>批处理阶段–多道批处理系统</h2><p>每次往内存中写入多道程序，<code>操作系统正式诞生</code>，并引入<code>中断</code>技术，由操作系统负责调度多道程序并发执行。</p><div class="note note-default">            <p>主要优点：多道程序<code>并发</code>执行，<code>共享</code>计算机资源，资源利用率大幅提升，CPU 和其他资源保持“忙碌”状态，系统吞吐量增大。</p><p>主要缺点：用户响应时间长，<code>没有人机交互功能</code>。(用户在提交作业后需要等待计算机处理完成，中间不能控制作业的执行)</p>          </div><img src="/blog/2021/03/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%8F%91%E5%B1%95%E5%92%8C%E5%88%86%E7%B1%BB/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%8D%95%E3%80%81%E5%A4%9A%E9%81%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%A4%BA%E4%BE%8B.png" class="" title="操作系统-单、多道操作系统示例"><h2 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a>分时操作系统</h2><p>计算机以<code>时间片</code>为单位轮流为各个用户/作业服务，各个用户可通过终端与计算机进行交互。</p><div class="note note-default">            <p>主要优点：用户请求即时响应，<code>解决了人机交互问题</code>。允许多个用户同时使用一台计算机。</p><p>主要缺点：<code>不能优先处理一些紧急任务</code>，操作系统对各个用户/作业都是完全公平的。</p>          </div><h2 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h2><span class="label label-success">解决及时响应紧急任务的问题。这类的紧急任务不需要时间片等待。</span><div class="note note-default">            <p>计算机系统接受到（外部）<code>中断</code>信号后及时响应处理，在严格的时限内处理完事件。</p><p>特点是<code>及时性</code>和<code>可靠性</code>。</p>          </div><img src="/blog/2021/03/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%8F%91%E5%B1%95%E5%92%8C%E5%88%86%E7%B1%BB/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%B8%A4%E7%A7%8D%E5%AE%9E%E6%97%B6%E7%B3%BB%E7%BB%9F%E7%A4%BA%E4%BE%8B.png" class="" title="操作系统-两种实时系统示例"><h2 id="分布式操作系统"><a href="#分布式操作系统" class="headerlink" title="分布式操作系统"></a>分布式操作系统</h2><p>（待续…）</p><h2 id="知识回顾"><a href="#知识回顾" class="headerlink" title="知识回顾"></a>知识回顾</h2><img src="/blog/2021/03/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%8F%91%E5%B1%95%E5%92%8C%E5%88%86%E7%B1%BB/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%88%86%E7%B1%BB%E6%80%BB%E7%BB%93.png" class="" title="操作系统-分类总结">]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>发展</tag>
      
      <tag>分类</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统-概念功能目标</title>
    <link href="/blog/2021/02/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E5%BF%B5%E5%8A%9F%E8%83%BD%E7%9B%AE%E6%A0%87/"/>
    <url>/blog/2021/02/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E5%BF%B5%E5%8A%9F%E8%83%BD%E7%9B%AE%E6%A0%87/</url>
    
    <content type="html"><![CDATA[<h2 id="知识总览"><a href="#知识总览" class="headerlink" title="知识总览"></a>知识总览</h2><div class="note note-success">            <ul><li>操作系统的概念</li><li>操作系统的功能和目标</li></ul>          </div><img src="/blog/2021/02/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E5%BF%B5%E5%8A%9F%E8%83%BD%E7%9B%AE%E6%A0%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E5%BF%B5%E5%8A%9F%E8%83%BD%E5%92%8C%E7%9B%AE%E6%A0%87-%E7%9F%A5%E8%AF%86%E6%80%BB%E8%A7%88.png" class="" title="操作系统-知识总览"><h2 id="操作系统的概念"><a href="#操作系统的概念" class="headerlink" title="操作系统的概念"></a>操作系统的概念</h2><div class="note note-default">            <p>直观的例子，打开（Mac 系统）活动监视器</p>          </div><img src="/blog/2021/02/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E5%BF%B5%E5%8A%9F%E8%83%BD%E7%9B%AE%E6%A0%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BD%AF%E7%A1%AC%E4%BB%B6%E7%AE%A1%E7%90%86%E7%9A%84%E7%A4%BA%E4%BE%8B.png" class="" title="操作系统-软硬件管理示例"><img src="/blog/2021/02/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E5%BF%B5%E5%8A%9F%E8%83%BD%E7%9B%AE%E6%A0%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E5%BF%B5.png" class="" title="操作系统-概念"><div class="note note-default">            <p>教科书解释：操作系统(Operating System, OS) </p>          </div><pre><code class="mermaid" >【从中间往上下两边看】是指控制和管理整个计算机系统的硬件和软件资源，并合理的组织调度计算机的工作和资源的分配；【从下往上看】以提供给用户和其他软件方便的接口和环境；【从上往下看】它是计算机系统中最基本的系统软件。</code></pre><h2 id="操作系统的功能和目标"><a href="#操作系统的功能和目标" class="headerlink" title="操作系统的功能和目标"></a>操作系统的功能和目标</h2><div>            <input type="checkbox" disabled ><span style="margin-left: 16px;">操作系统作为系统资源的管理者（这些资源包括软件、硬件、文件等），需要提供什么功能？</span>          </div><div>            <input type="checkbox" disabled ><span style="margin-left: 16px;">操作系统作为用户与计算机硬件之间的接口，需要为上层的用户、应用程序提供简单易用的服务，需要实现什么功能？</span>          </div><div>            <input type="checkbox" disabled ><span style="margin-left: 16px;">操作系统作为最接近硬件的层次，需要在纯硬件的基础上实现什么功能？</span>          </div><img src="/blog/2021/02/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E5%BF%B5%E5%8A%9F%E8%83%BD%E7%9B%AE%E6%A0%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%8A%9F%E8%83%BD%E5%92%8C%E7%9B%AE%E6%A0%87.png" class="" title="操作系统-功能和目标"><div class="note note-default">            <p>① 操作系统作为系统资源的管理者（这些资源包括软件、硬件、文件等），需要提供什么功能？</p>          </div><span class="label label-success">如下示例:进程是一个程序的执行过程，执行前需要`将程序放入内存中`,才能被 CPU 处理</span><img src="/blog/2021/02/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E5%BF%B5%E5%8A%9F%E8%83%BD%E7%9B%AE%E6%A0%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E8%80%85%E7%A4%BA%E4%BE%8B.png" class="" title="操作系统-资源管理者示例"><img src="/blog/2021/02/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E5%BF%B5%E5%8A%9F%E8%83%BD%E7%9B%AE%E6%A0%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%BD%9C%E4%B8%BA%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90%E7%9A%84%E7%AE%A1%E7%90%86%E8%80%85.png" class="" title="操作系统-系统资源管理者"><div class="note note-default">            <p>② 操作系统作为用户与计算机硬件之间的接口，需要为上层的用户、应用程序提供简单易用的服务，需要实现什么功能？</p>          </div><img src="/blog/2021/02/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E5%BF%B5%E5%8A%9F%E8%83%BD%E7%9B%AE%E6%A0%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%BD%9C%E4%B8%BA%E7%94%A8%E6%88%B7%E5%92%8C%E7%A1%AC%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E6%8E%A5%E5%8F%A3.png" class="" title="操作系统-作为用户和硬件之间的接口"><img src="/blog/2021/02/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E5%BF%B5%E5%8A%9F%E8%83%BD%E7%9B%AE%E6%A0%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%94%A8%E6%88%B7%E6%8E%A5%E5%8F%A3%E7%A4%BA%E4%BE%8B.png" class="" title="操作系统-用户接口示例"><div class="note note-default">            <p>③ 操作系统作为最接近硬件的层次，需要在纯硬件的基础上实现什么功能？</p>          </div><img src="/blog/2021/02/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E5%BF%B5%E5%8A%9F%E8%83%BD%E7%9B%AE%E6%A0%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%BD%9C%E4%B8%BA%E6%9C%80%E6%8E%A5%E8%BF%91%E7%A1%AC%E4%BB%B6%E7%9A%84%E5%B1%82%E6%AC%A1.png" class="" title="操作系统-作为最接近硬件的层次"><h2 id="知识回顾"><a href="#知识回顾" class="headerlink" title="知识回顾"></a>知识回顾</h2><img src="/blog/2021/02/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E5%BF%B5%E5%8A%9F%E8%83%BD%E7%9B%AE%E6%A0%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E5%BF%B5%E5%92%8C%E5%8A%9F%E8%83%BD%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE.png" class="" title="操作系统-概念和功能知识回顾">]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>功能</tag>
      
      <tag>目标</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统-基本特征</title>
    <link href="/blog/2021/02/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81/"/>
    <url>/blog/2021/02/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81/</url>
    
    <content type="html"><![CDATA[<h2 id="知识总览"><a href="#知识总览" class="headerlink" title="知识总览"></a>知识总览</h2><div class="note note-success">            <ul><li>操作系统的四个基本特征</li></ul>          </div><img src="/blog/2021/02/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%89%B9%E5%BE%81%E6%80%BB%E8%A7%88.png" class="" title="操作系统-四个基本特征"><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><div class="note note-default">            <p>指多个程序在同一<code>时间间隔内</code>发生，这些程序在<code>宏观上是同时发生</code>的。但<code>微观上是交替发生</code>的。</p>          </div><span class="label label-warning">容易混淆概念--并行: 指多个程序在同一时刻发生。</span><pre><code class="mermaid" >一个单核处理机（CPU）同一时刻只能执行一个程序因此需要操作系统负责协调多个程序交替执行（微观）对于用户看起来是同时执行（宏观）</code></pre><span class="label label-success">操作系统就是伴随“多道程序技术”而出现的。因此，操作系统和程序并发是一起诞生的。</span><h2 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h2><div class="note note-default">            <p>即资源共享，指系统中的资源可供内存中多个并发执行的进程共同使用。</p>          </div><img src="/blog/2021/02/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%85%B1%E4%BA%AB.png" class="" title="操作系统-共享"><pre><code class="mermaid" >* 互斥共享： 微信和 QQ 无法同时开启摄像头* 分时共享： 微信和 QQ "同时"传送硬盘里的文件</code></pre><img src="/blog/2021/02/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%B9%B6%E5%8F%91%E5%92%8C%E5%85%B1%E4%BA%AB%E7%9A%84%E5%85%B3%E7%B3%BB.png" class="" title="操作系统-并发和共享的关系"><h2 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h2><div class="note note-default">            <p>把物理计算资源抽象成若干个逻辑上的对应物，按时间片轮转供多个程序使用。</p>          </div><img src="/blog/2021/02/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%99%9A%E6%8B%9F%E7%A4%BA%E4%BE%8B.png" class="" title="操作系统-虚拟示例"><pre><code class="mermaid" >* 时分复用： 微观上，CPU 在各个足够小的时间片内交替为各个进程服务* 空分复用： 虚拟存储技术</code></pre><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><div class="note note-default">            <p>在多道程序环境下，允许多个程序并发执行，由于资源有限，进程的执行过程不是一贯到底而是走走停停，以不可预知的速度向前推进。</p>          </div><h2 id="知识回顾"><a href="#知识回顾" class="headerlink" title="知识回顾"></a>知识回顾</h2><img src="/blog/2021/02/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%89%B9%E5%BE%81%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE.png" class="" title="操作系统-特征知识回顾">]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>特征</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gitalk-auto-init</title>
    <link href="/blog/2021/01/18/gitalk-auto-init/"/>
    <url>/blog/2021/01/18/gitalk-auto-init/</url>
    
    <content type="html"><![CDATA[<p>  <a title="计算机基础" href="javascript:void(0);">    <img style="display:inline-block;" alt="计算机基础" src="https://img.shields.io/badge/计算机基础-多路复用-orange?style=flat">  </a>  <a title="License" href="javascript:void(0);">    <img style="display:inline-block;" alt="License" src="https://img.shields.io/github/license/fluid-dev/hexo-theme-fluid.svg?style=flat">  </a></p><span class="label label-danger">danger aa</span><div>            <input type="checkbox" disabled checked="checked"><span style="margin-left: 16px;">熟悉</span>          </div>            <input type="checkbox" disabled ><span style="margin-left: 16px;">了解</span>                      <input type="checkbox" disabled checked="checked"><span style="margin-left: 16px;">精通</span>          <pre><code class="mermaid" >这是一个大长块文字</code></pre><div class="note note-info">            <p>info 提示块标签</p>          </div><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><hr><p><em>斜体</em><br><strong>粗体</strong><br><strong><em>粗斜体</em></strong></p><p><del>删除线文本</del></p><blockquote><p><strong>这篇文章涵盖的知识点</strong><br>第一段<br>第二段引用的内容</p></blockquote><p><u>下划线文本</u></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>():</span><br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><ul><li>无序第一项<ol><li>有序子列表 1</li><li>有序子列表 2</li></ol></li><li>无序第二项</li></ul><ol><li>有序第一项<ol><li>子列表 1</li><li>子列表 2</li></ol></li><li>有序第二项<ul><li>无序子列表 1</li><li>无序子列表 2</li></ul></li></ol><p>这是一段普通的文本，其中高亮 <code>python</code> 代码块</p><p>这是超链接示例: <a href="https://www.baidu.com/">百度搜索</a></p><p>表格示例<br>| 参数 | 类型 | 值 |<br>| :—- | :—- | :—- |<br>| name | char | 必填 |<br>| age | int | 选填 |</p><p>转义字符<br>&gt;<br>\<br>* 星号<br># 井字号<br>+ 加号<br>- 减号</p><p><kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs flow">st&#x3D;&gt;start: 开始框<br>op&#x3D;&gt;operation: 处理框<br>cond&#x3D;&gt;condition: 判断框(是或否?)<br>sub1&#x3D;&gt;subroutine: 子流程<br>io&#x3D;&gt;inputoutput: 输入输出框<br>e&#x3D;&gt;end: 结束框<br>st-&gt;op-&gt;cond<br>cond(yes)-&gt;io-&gt;e<br>cond(no)-&gt;sub1(right)-&gt;op<br>​&#96;&#96;&#96;<br><br><br><br>&#123;% asset_img post-by-portal.png post-by-portal %&#125;<br>&#123;% asset_img post-by-script.png post-by-script %&#125;<br><br>&#96;&#96;&#96;python<br>#!&#x2F;usr&#x2F;bin&#x2F;env python<br># -*- coding: utf-8 -*-<br><br>import requests<br>import json<br><br>def run():<br>    username &#x3D; &#39;MengjieLee&#39;<br>    repo_name &#x3D; &#39;blog&#39;<br>    session &#x3D; requests.Session()<br>    session.auth &#x3D; (&#39;MengjieLee&#39;, &#39;Authorization: token xx&#39;)<br>    session.headers &#x3D; &#123;<br>        &#39;Accept&#39;: &#39;application&#x2F;vnd.github.v3+json&#39;,<br>        &#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;85.0.4183.59 Safari&#x2F;537.36 Edg&#x2F;85.0.564.30&#39;<br>    &#125;<br><br>    issue &#x3D; &#123;<br>        &#39;title&#39;: &#39;Python 3.6-内置函数 - Hexo&#39;,<br>        &#39;body&#39;: &#39;https:&#x2F;&#x2F;mengjielee.github.io&#x2F;blog&#x2F;2021&#x2F;01&#x2F;17&#x2F;Python-3-6-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0&#x2F;&#39;,<br>        &#39;labels&#39;: [&#39;Gitalk&#39;, &#39;c5bc3c467c6cf4ae08433c846478c9bb&#39;]<br>    &#125;<br>    github_url &#x3D; &quot;https:&#x2F;&#x2F;api.github.com&#x2F;repos&#x2F;&quot; + username + &quot;&#x2F;&quot; + repo_name + &quot;&#x2F;issues&quot;<br>    resp &#x3D; session.post(url&#x3D;github_url, data&#x3D;json.dumps(issue))<br>    print(resp)<br><br>if __name__ &#x3D;&#x3D; &#39;__main__&#39;:<br>    run()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>github</category>
      
      <category>自动化</category>
      
      <category>第三方评论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>虚拟机</title>
    <link href="/blog/2021/01/18/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <url>/blog/2021/01/18/%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Python-内置函数</title>
    <link href="/blog/2021/01/17/Python-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/"/>
    <url>/blog/2021/01/17/Python-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>多路复用</title>
    <link href="/blog/2021/01/16/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    <url>/blog/2021/01/16/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>  <a title="计算机基础" href="javascript:void(0);">    <img style="display:inline-block;" alt="计算机基础" src="https://img.shields.io/badge/计算机基础-多路复用-orange?style=flat">  </a>  <a title="License" href="javascript:void(0);">    <img style="display:inline-block;" alt="License" src="https://img.shields.io/github/license/fluid-dev/hexo-theme-fluid.svg?style=flat">  </a></p><p>???</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并发</tag>
      
      <tag>原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
