<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>RPC</title>
    <link href="/blog/2024/12/10/RPC/"/>
    <url>/blog/2024/12/10/RPC/</url>
    
    <content type="html"><![CDATA[<h2 id="知识总览"><a href="#知识总览" class="headerlink" title="知识总览"></a>知识总览</h2><p>RPC (Remote Procedure Call) 远程过程调用</p><img src="/blog/2024/12/10/RPC/graph_1.png" class="graph_1.png.png">]]></content>
    
    
    
    <tags>
      
      <tag>分布式 通信 协议 网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL-锁</title>
    <link href="/blog/2024/10/11/MySQL-%E9%94%81/"/>
    <url>/blog/2024/10/11/MySQL-%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h2 id="MySQL-有哪些锁"><a href="#MySQL-有哪些锁" class="headerlink" title="MySQL 有哪些锁"></a>MySQL 有哪些锁</h2><p>根据加锁的范围，可分为<code>全局锁</code>、<code>行锁</code>和<code>表锁</code></p><h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><div class="note note-default">            <p>全局锁是怎么用的？</p>          </div><p><code>flush tables with read lock</code> 执行全局锁，<code>整个数据库就处于只读状态</code>，此时其他线程执行如下操作都被阻塞：</p><ul><li>对<code>数据的增删改</code>操作，比如 insert、delete、update 等语句</li><li>对<code>表结构的更改</code>操作，比如 alter table、drop table 等语句</li></ul><p><code>unlock tables</code> 释放全局锁。另外，会话 session 断开后，全局锁会被自动释放</p><div class="note note-default">            <p>全局锁应用场景是什么？</p>          </div><p>全局锁主要应用于<code>全库逻辑备份</code>。</p><div class="note note-default">            <p>全局锁会带来什么影响？</p>          </div><p>意味着整个数据库都是只读状态。比如在备份期间，业务职能读数据，会造成业务停滞。</p><div class="note note-default">            <p>使用全局锁会影响业务，那有什么解决方案？</p>          </div><p>利用数据库的引擎的特点，比如 InnoDB ，默认支持<code>可重复读的隔离级别</code>，在其 MVCC 支持下，备份期间依然可以进行业务操作。</p><p>但是，对于其他不支持事务的引擎，在备份数据时就得避开业务高峰时间段，比如凌晨进行并采取<code>全局锁</code>的方法。</p><h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span> 表级别的共享锁，也就是读锁（共享锁允许多个事务同时读取一个资源，但不允许任何事务修改它）<br>lock tables t_products read;<br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span> 表级别的独占锁（排他锁），也就是写锁（其他事务无法同时获取共享锁或独占锁，直到原始事务释放了其锁。）<br>lock tables t_products write;<br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span> 释放当前会话的所有表锁，或会话退出后也会自行释放<br>unlock tables t_products<br></code></pre></td></tr></table></figure><p>不过表锁颗粒度太大影响并发性能，所以 InnoDB 实现了颗粒度更细的<code>行级锁</code>。</p><h3 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h3><p>元数据锁（MDL），不需要显示启动，因为当数据库表操作过程会自动加上：</p><ul><li>CRUD 操作，加的是<code>MDL 读锁</code></li><li>表结构变更操作，加的是<code>MDL 写锁</code></li></ul><div class="note note-default">            <p>MDL 不需要显式调用，那么是什么时候释放？</p>          </div><p>MDL 是在事务提交后才会释放，这意味着<code>事务执行期间，MDL 是一直持有的</code><br>例，线程 A 启动事务但不提交（即<code>长事务</code>），执行 select 语句，此时给表加上 MDL 读锁,线程 B 陆续请求 select 不会阻塞，因为<code>读读</code>不冲突；但线程 C 修改表字段申请不到 MDL 写锁则会被阻塞，并且<code>之后所有的 select 语句</code>都会被阻塞，这样就会大量线程阻塞导致数据库异常断开。</p><div class="note note-default">            <p>为什么线程 C 因申请不到 MDL 写锁，被阻塞后，而导致后续的申请读锁查询也会被阻塞？</p>          </div><p>申请 MDL 锁的操作会形成一个队列，队列中<code>写锁获取优先级高于读锁</code>,一旦出现 MDL 写锁等待，因此会阻塞后续该表的所有 CRUD 操作。<br>解决方案：在对表结构变更前<code>看看数据库的长事务，是否有事务已经对表加了 MDL 读锁</code>，可以考虑 kill 掉这个长事务，然后进行表结构的变更。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql">在 MySQL 中，MDL（Metadata Lock, 即 lock_type <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;MDL&#x27;</span>）的锁模式（lock_mode）标识通常有以下几种：<br>`S`：共享（Shared）锁，允许多个事务同时持有该锁，用于读取操作。<br>`X`：独占（Exclusive）锁，只允许一个事务持有该锁，用于写入或修改操作。<br>`<span class="hljs-keyword">IS</span>`：意向共享（Intention Shared）锁，表示事务打算在表或行级别获取共享锁。<br>`IX`：意向独占（Intention Exclusive）锁，表示事务打算在表或行级别获取独占锁。<br>AUTO_INC：自增锁，用于控制自增值的分配。<br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span> 查看数据库中锁的信息（因数据库版本不同略有差异）<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> performance_schema.data_locks;<br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span> 查看数据库中等待锁的事务信息<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> performance_schema.data_lock_waits;<br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span> 这里的 trx_id 是要终止的事务的事务 ID<br>KILL trx_id;<br></code></pre></td></tr></table></figure><h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><p>当执行插入、更新、删除操作：先给表加上<code>意向独占锁</code>，然后对该记录加<code>独占锁</code>。<br>而普通的 select 是不会加行级锁的，<code>普通的 select 语句是利用 MVCC 实现一致性读</code>，是<code>无锁</code>的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span> 先给表上加意向共享锁，然后对表中被读取的记录加共享锁<br><span class="hljs-keyword">select</span> ... lock <span class="hljs-keyword">in</span> share mode;<br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span> 先给表上加意向独占锁，然后对表中被操作的记录加独占锁<br><span class="hljs-keyword">select</span> ... <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;<br></code></pre></td></tr></table></figure><p>意向共享锁，意向独占锁，均是<code>表级锁</code>:</p><ul><li>它们和行级的共享锁和独占锁<code>不冲突</code></li><li>意向锁之间也<code>不冲突</code>，但和共享表锁（<code>lock tables ... read</code>）和独占表锁（<code>lock tables ... write</code>）<code>会冲突</code><br>表锁和行锁是满足<code>读读共享</code>，<code>读写互斥</code>，<code>写写互斥</code>。</li></ul><p>意向锁的目的：<code>为了快速判断表里是否有记录被加锁</code></p><h3 id="AUTO-INC-锁"><a href="#AUTO-INC-锁" class="headerlink" title="AUTO-INC 锁"></a>AUTO-INC 锁</h3><p>表里的主键通常设置<code>AUTO_INCREMENT</code>设成自增。数据库会自动给主键赋值递增的值，这主要是通过<code>AUTO-INC 锁</code>实现的。<br>AUTO-INC 锁是特殊的<code>表锁</code>机制，锁<code>不是在一个事务提交后才释放，而是在执行完插入语句后就立即释放</code>。<br>这样理解，在插入数据时，会加一个表级别的 AUTO-INC 锁，然后为被 AUTO_INCREMENT 修饰的字段赋值递增的值，等插入语句执行完成后，才会把 AUTO-INC 锁释放。<br>所以说，一个事务有 AUTO-INC 锁的过程中，<code>其他事务的如果要想该表插入语句都会被阻塞</code>，这样就保证插入数据时，被 AUTO_INCREMENT 修饰的字段的值是连续递增的。<br>但这样会导致性能的降低，这样 InnoDB 存储引擎提供了一种<code>轻量级的锁</code>(默认设置)来实现自增。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%innodb_autoinc_lock_mode%&#x27;</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">--------------------------+-------+</span><br><span class="hljs-operator">|</span> Variable_name            <span class="hljs-operator">|</span> <span class="hljs-keyword">Value</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------------------------+-------+</span><br><span class="hljs-operator">|</span> innodb_autoinc_lock_mode <span class="hljs-operator">|</span> <span class="hljs-number">2</span>     <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------------------------+-------+</span><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.04</span> sec)<br></code></pre></td></tr></table></figure><p>故此，InnoDB 存储引擎提供了个 innodb_autoinc_lock_mode 的系统变量来控制自增是选择用那种锁：</p><ul><li>✅（性能最佳）innodb_autoinc_lock_mode = 2， 轻量级锁，申请自增主键后就释放锁，并不需要等语句执行后才释放。</li><li>innodb_autoinc_lock_mode = 0， AUTO-INC 锁，语句执行结束后才释放锁。</li><li>innodb_autoinc_lock_mode = 1：<ul><li>普通 insert 语句，自增锁在申请之后就马上释放</li><li>类似 insert … select 这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放</li></ul></li></ul><p>innodb_autoinc_lock_mode = 2 是性能最高的方式，但在与 binlog 的日志格式是 statement （记录的语句是原始语句）一起使用的时候，在<code>主从复制的场景</code>中会发生<code>数据不一致的问题</code>。binlog 拿去从库执行是按照顺序执行原始语句，因此不会发生像主库那样多个session同时执行插入数据的场景。要避免这样的情况发生，此时需要同时设置 <code>binlog_format = row</code>，技能提升并发性，也不会出现数据不一致的问题了。</p><h3 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h3><p>InnoDB 引擎支持行级锁，MyISAM 引擎不支持行级锁。</p><p>普通的 select 是快照度不会对记录加锁。如果要在查询时对记录加行锁（即<code>锁定读</code>），可以使用下面两个方式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span> 先给表上加意向共享锁，然后对表中被读取的记录加共享锁<br><span class="hljs-keyword">select</span> ... lock <span class="hljs-keyword">in</span> share mode;<br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span> 先给表上加意向独占锁，然后对表中被操作的记录加独占锁<br><span class="hljs-keyword">select</span> ... <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;<br></code></pre></td></tr></table></figure><p>上面两条语句必须在一个事务中，因为<code>事务提交了，锁就会被释放</code>。所以要加上 begin、start transaction 或者 set autocommit = 0。<br>共享锁（S锁）满足读读共享，读写互斥。<br>独占锁（X锁）满足写写互斥，读写互斥。<br>行级锁的类型主要有三类：</p><ul><li>Record Lock 记录锁，将一条记录锁上</li><li>Gap Lock 间隙锁，锁定一个范围，但<code>不包含记录本身</code></li><li>Next-key Lock 临键锁，上述两种的组合（Record Lock + Gap Lock），锁定一个范围，并包含记录本身</li></ul><h4 id="Record-Lock"><a href="#Record-Lock" class="headerlink" title="Record Lock"></a>Record Lock</h4><p>Record lock 称为记录锁，有 S 锁和 X 锁之分：</p><ul><li>当一个事务对记录加了 S 记录锁，其他事务也可以继续对该记录加 S 记录锁，但并不可以加 X 记录锁</li><li>当一个事务对记录加了 X 记录锁，其他事务不可以加 S 或 X 记录锁<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- X 记录锁</span><br>mysql <span class="hljs-operator">&gt;</span> <span class="hljs-keyword">begin</span>;<br>mysql <span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> product <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;<br></code></pre></td></tr></table></figure></li></ul><p>当事务执行 commit 后，事务过程中生成的锁都会被释放。</p><h4 id="Gap-Lock"><a href="#Gap-Lock" class="headerlink" title="Gap Lock"></a>Gap Lock</h4><p>Gap Lock 间隙锁，只存在于<code>可重复读隔离级别</code>，目的是为了解决可重复读隔离级别下幻读的现象。<br>例：表中有一个范围 id 为(3,5)间隙锁，那么其他事务就无法插入 id=4 这条记录了，这样就有效防止幻读现象的发生。</p><p>间隙锁虽然存在于 X 和 S 型间隙锁之分，但没有区别，<code>间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的</code>。</p><h4 id="Next-Key-Lock"><a href="#Next-Key-Lock" class="headerlink" title="Next-Key Lock"></a>Next-Key Lock</h4><p>Next-Key Lock 临键锁，是 Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。<br>例，表中有一个范围 id 为 (3, 5] 的 next-key lock， 那么其他事务既不能插入 id = 4 的记录，也不能修改 id = 5 的这条记录。<br>所以 next-key lock 既能保护该记录，也能阻止其他事务将新记录插入到被保护记录前面的间隙中。<br><code>next-key lock 是包含间隙锁+记录锁的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型 next-key lock 时，会被阻塞！</code><br>综上所述，间隙锁场景里，是需要考虑 X 型和 S 型关系的（类似记录锁的关系）。</p><h4 id="插入意向锁"><a href="#插入意向锁" class="headerlink" title="插入意向锁"></a>插入意向锁</h4><p>插入意向锁名字虽然有意向锁，但它<code>并不是意向锁，它是一种特殊的间隙锁，属于行级别锁</code>（间隙锁锁住的是一个区间，那么<code>插入意向锁</code>锁住的就是一个点。从这个角度讲，插入意向锁是一种特殊的间隙锁）。</p><ul><li>一个事务在插入一条记录时，需要判断插入位置是否已经被其他事务加了 gap lock 间隙锁（特别说明， next-key lock 也包含间隙锁）。</li><li>如果有间隙锁，插入操作会<code>阻塞</code>，知道拥有间隙锁的事务提交为止（释放间隙锁的时刻），在此期间会生成一个<code>插入意向锁</code>，表名有事务想在某个区间插入新记录，但是现在处于等待状态。</li></ul><p>PS：MySQL 加锁，生成锁结构，然后设置锁的状态，如果锁状态是等待，并不是意味事务成功获取到了锁，只有锁的状态为正常，才代表事务成功获取到了锁。</p><p>插入意向锁和间隙锁的另一个重要差别：尽管插入意向锁属于间隙锁，但两个事务不能再同一时间内，一个拥有间隙锁，另一个拥有该间隙区间内的插入意向锁（除非插入意向锁不在间隙锁区间内）。</p><h2 id="MySQL-如何加锁"><a href="#MySQL-如何加锁" class="headerlink" title="MySQL 如何加锁"></a>MySQL 如何加锁</h2><h3 id="什么-SQL-语句会加行级锁"><a href="#什么-SQL-语句会加行级锁" class="headerlink" title="什么 SQL 语句会加行级锁"></a>什么 SQL 语句会加行级锁</h3><p>InnoDB 引擎是支持行级锁的，MyISAM 引擎不支持行级锁。所以提到 MySQL 加行级锁，其实是在说 InnoDB 引擎是怎么加行级锁的。</p><p>普通的 select 语句是不会对记录加锁的（除了串行化隔离级别），因为它属于快照读，是通过 MVCC 实现。</p><p>如果要在查询时对记录加行级锁，即<code>锁定读</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">begin</span>;(或 <span class="hljs-keyword">start</span> transaction;)<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span> 先给表上加意向共享锁，然后对表中被读取的记录加共享锁（S型锁）<br><span class="hljs-keyword">select</span> ... lock <span class="hljs-keyword">in</span> share mode;<br><br><span class="hljs-keyword">begin</span>;(或 <span class="hljs-keyword">start</span> transaction;)<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span> 先给表上加意向独占锁，然后对表中被操作的记录加独占锁（X型锁）<br><span class="hljs-keyword">select</span> ... <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;<br></code></pre></td></tr></table></figure><p>上述两个方式必须在事务中，<code>因为当事务提交了，锁才会被释放</code>，所以使用之前要加上 begin 或者 start transaction 开始事务的语句。</p><p><code>update</code> 和 <code>delete</code> 操作<code>都会加行级锁且都是独占锁（X型）</code> </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span> 先给表上加意向独占锁，然后对表中被读取的记录加独占锁（X型锁）<br><span class="hljs-keyword">update</span> <span class="hljs-keyword">table</span>  ... <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span> 先给表上加意向独占锁，然后对表中被操作的记录加独占锁（X型锁）<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">table</span> ... <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h3 id="行级锁有哪些种类"><a href="#行级锁有哪些种类" class="headerlink" title="行级锁有哪些种类"></a>行级锁有哪些种类</h3><p>不同的隔离级别下，行级锁的种类是不同的。<br>TODO</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL-事务</title>
    <link href="/blog/2024/10/05/MySQL-%E4%BA%8B%E5%8A%A1/"/>
    <url>/blog/2024/10/05/MySQL-%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="知识总览"><a href="#知识总览" class="headerlink" title="知识总览"></a>知识总览</h2><ul><li>事务的隔离级别如何实现？</li><li>事务有哪些特性？</li><li>并行事务会引发脏读、不可重复读、幻读问题</li><li>事务的隔离级别有哪些？</li><li>Read View 在 MVCC 里如何工作？</li><li>可重复读是如何工作的？</li><li>读提交时如何工作的？</li><li>MySQL 可重复读隔离级别，完全解决欢度了吗？</li><li>什么是幻读？</li><li>快照读是如何避免幻读的?</li><li>当前读是如何避免幻读的？</li><li>幻读被完全解决了吗？</li><li>总结</li></ul><p>事务（Transaction）解决业务里的所有数据库的操作不可分割，要么全部成功，要么全部失败，不允许出现中间状态的数据。</p><p>事务是由 MySQL 引擎来实现的，常见的 InnoDB 引擎是支持事务的。</p><h2 id="事务有哪些特性？"><a href="#事务有哪些特性？" class="headerlink" title="事务有哪些特性？"></a>事务有哪些特性？</h2><p>实现事务必须要遵循 4 个特性<code>ACID</code>：</p><ul><li><code>原子性 (Atomicity)</code>：一个事务的所有操作，要么全部完成，要么全部不完成，执行过程发生错误，会被回滚到事务开始前的状态。</li><li><code>一致性（Consistency）</code>：事务操作前、后的数据满足完整性约束，数据库保持一致性状态。如银行中两个用户A,B总共金额2000元，不管他们如何交易，总数不能变。</li><li><code>隔离性（Isolation）</code>：数据库允许多个并发事务同时对其数据进行读写和修改，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。也就是说消费者购买商品这个事务，是不影响其他消费者同时购买的。</li><li><code>持久性（Durability）</code>：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li></ul><p>InnoDB 引擎通过什么技术来保证事务的 ACID：</p><ul><li><code>原子性</code>是通过<code>undo log（回滚日志）</code>来实现</li><li><code>一致性</code>是通过<code>持久性+原子性+隔离性</code>来保证</li><li><code>隔离性</code>是通过<code>MVCC（多版本并发控制）或锁机制</code>来实现</li><li><code>持久性</code>是通过<code>redo log（重做日志）</code>来实现</li></ul><h2 id="并行事务会引发什么问题？"><a href="#并行事务会引发什么问题？" class="headerlink" title="并行事务会引发什么问题？"></a>并行事务会引发什么问题？</h2><p>MySQL 服务端是允许多个 client 连接的，这意味着 MySQL 会出现同时处理多个事务的情况。<br>那么在同时处理多个事务的时候，就可能出现：</p><ul><li><code>脏读（dirty read）</code></li><li><code>不可重复读（non-repeatable read）</code></li><li><code>幻读（phantom read）</code></li></ul><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>如果<code>一个事务B内读到</code>了另一个事务A<code>未提交事务修改过的数据</code>，就意味着发生了<code>脏读</code>现象。如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">事务A<span class="hljs-comment">--&gt;启动事务--&gt;读取余额--&gt;更新余额--&gt;触发回滚-----&gt;结束</span><br>数据库<span class="hljs-comment">------------ 100 ------ 200 ---- `100` ---------</span><br>事务B<span class="hljs-comment">--&gt;启动事务----------&gt;读取余额`200`------------&gt;结束</span><br></code></pre></td></tr></table></figure><p>因为事务A是还没提交更新事务，随时可能发生回滚，事务B所得到的数据就是过期的数据，这种现象就称谓<code>脏读</code>。</p><h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>如果<code>一个事务内多次读取同一个数据</code>，如果出现前后两次读出的数据不一样的情况，就意味着发生了<code>不可重复读</code>现象。如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">事务A<span class="hljs-comment">--&gt;启动事务--&gt;读取余额-----&gt;更新余额--&gt;提交事务---------&gt;结束</span><br>数据库<span class="hljs-comment">-----------    100   ------       `200`     ------------</span><br>事务B<span class="hljs-comment">--&gt;启动事务--&gt;读取余额`100`---&gt;读取余额`200`  ---------&gt;结束</span><br></code></pre></td></tr></table></figure><h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><p>如果<code>一个事务内多次查询某个符合查询条件的记录数量出现不一致</code>，则意味着发生了<code>幻读</code>现象.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">事务A<span class="hljs-comment">--&gt;启动事务--&gt;读取价格大于100的商品数量-----&gt;插入一条价格为150商品---&gt;提交事务---------&gt;结束</span><br>数据库<span class="hljs-comment">------------        `10`         ------              `11`            -----------</span><br>事务B<span class="hljs-comment">--&gt;启动事务--&gt;读取价格大于100的商品数量`10`--&gt;读取价格大于100的商品数量`11`  ----------&gt;结束</span><br></code></pre></td></tr></table></figure><h2 id="事务的隔离级别有哪些？"><a href="#事务的隔离级别有哪些？" class="headerlink" title="事务的隔离级别有哪些？"></a>事务的隔离级别有哪些？</h2><p>当多个实物并发执行时，可能会遇到<code>脏读</code>，<code>不可重复读</code>和<code>幻读</code>，这些现象会对实物的一致性产生不同的影响：</p><ul><li>脏读：读到其他事务未提交的数据</li><li>不可重复读：前后读取的数据结果不一致（类似幂等性不一致）</li><li>幻读：前后读取的记录数量不一致</li></ul><p>此三个现象的严重排序如下：<br>脏读 &gt; 不可重复读 &gt; 幻读</p><p>SQL 标准提出了四种隔离级别来规避这些现象（隔离级别越高，性能效率越低）：</p><ul><li><code>读未提交（read uncommitted）</code>：一个事务未提交之前，它的更新能被其他事务读取<ul><li>脏读、不可重复读、幻读</li></ul></li><li><code>读提交（read committed）</code>：一个事务提交之后，它的更新才能被其他事务读取<ul><li>不可重复读，幻读</li></ul></li><li><code>可重复读（repeatable read）</code>（MySQL InnoDB 引擎默认隔离级别）：一个事务处理过程中读取的结果，和事务启动时看到的结果一致<ul><li>幻读</li></ul></li><li><code>串行化（serializable）</code>：对操作记录加上读写锁，在多个事务对记录发生读写冲突时，后访问事务需要等前面的事务执行完成之后才能继续执行。<ul><li>上述三种现象均不会发生</li></ul></li></ul><p><code>MySQL InnoDB 引擎的默认隔离级别虽然是可重复读，但它很大程度上避免了幻读现象，但也不是完全解决</code>，所以额外的幻读解决方案有两种：</p><ul><li>针对<code>快照读</code>（普通 select … 语句）,是通过<code>MVCC</code>方式解决了幻读</li><li>针对<code>当前读</code>（select … for update 等语句），是通过<code>next-key lock（记录锁+间隙锁）</code>方式解决幻读。在 next-key lock 锁范围内插入一条记录，这个插入语句会被阻塞，waiting 超时则无法成功插入。</li></ul><p>这四种隔离级别具体是如何实现的？</p><ul><li><code>读未提交</code>，直接读取最新的数据</li><li><code>读提交</code>，[Read View 机制] <code>每个语句执行前</code>都会重新生成一个<code>Read View</code></li><li><code>可重复读</code>，[Read View 机制] <code>启动事务时</code>生成一个<code>Read View</code>，然后整个事务期间都用这个 read view</li><li><code>串行化</code>，加读写锁避免并行访问</li></ul><p>执行<code>开始事务</code>命令，并不意味着启动了事务。在 MySQL 有两种开启事务的命令：</p><ul><li>begin/start transaction<ul><li>并不代表事务启动，而是只有当执行了第一条 select 语句才是事务真正启动时机</li></ul></li><li>start transaction with consistent snapshot<ul><li>立即启动事务</li></ul></li></ul><h2 id="Read-View-在-MVCC-里如何工作的？"><a href="#Read-View-在-MVCC-里如何工作的？" class="headerlink" title="Read View 在 MVCC 里如何工作的？"></a>Read View 在 MVCC 里如何工作的？</h2><p>先了解下面两个知识点：</p><ul><li>四个字段<ul><li><code>creator_trx_id</code>，创建该 Read View 事务的事务 ID</li><li><code>m_ids</code>，创建 Read View 时，当前数据库中<code>活跃事务（启动但未提交）</code>的事务 ID 列表</li><li><code>min_trx_id</code>，活跃事务中 ID 最小的事务</li><li><code>max_trx_id</code>，数据库创建下一个新事务的 ID 值</li></ul></li><li>聚簇索引记录中两个跟事务相关的隐藏列<ul><li><code>trx_id</code>，事务对某一条聚簇索引记录修改时，就会把<code>事务 ID 记录在 trx_id y隐藏列里</code></li><li><code>roll_pointer</code>，旧版本记录写入<code>undo log</code>，同时<code>将旧版本记录的指针记录在roll_pointer里</code></li></ul></li></ul><p>在创建 Read View 后，我们可以将记录的 trx_id 划分如下三种情况：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">&lt;trx_id&gt; = &#123;已提交事务|&lt;min_trx_id&gt;|已启动但&lt;m_ids&gt;未提交的事务|&lt;max_trx_id&gt;|还没有开启的事务&#125;<br></code></pre></td></tr></table></figure><p>一个事务去访问记录的时候，除了自己的更新记录总是可见之外，还有如下几种情况：</p><ul><li>如果记录的 trx_id 小于 Read View 的 <code>min_trx_id</code>，表示这个版本的记录是在创建 Read View 之<code>前</code>就已经提交的事务生成的，所以该版本的记录对当前事务是<code>可见</code></li><li>如果记录的 trx_id 大于 Read View 的 <code>max_trx_id</code>，表示这个版本的记录是在创建 Read View 之<code>后</code>启动新事务生成的，所以该版本的记录对当前事务是<code>不可见</code></li><li>如果记录的 trx_id 在 Read View 的 <code>min_trx_id</code> 和 <code>max_trx_id</code> 之间，则进一步判断 trx_id 是否在 m_ids 列表中：<ul><li>如果记录的 trx_id 在 m_ids 列表中，表示生成该版本记录的活跃事务依然活跃且并未提交，所以该版本的记录对当前事务<code>不可见</code></li><li>如果记录的 trx_id 不在 m_ids 列表中，表示生成该版本记录的活跃事务已提交，所以该版本记录对当前事务<code>可见</code></li></ul></li></ul><p>上述通过<code>版本链</code>来控制并发事务访问同一个记录的行为就叫 MVCC（Multi-Version Concurrency Control，多版本并发控制）</p><h2 id="可重复读是如何工作的"><a href="#可重复读是如何工作的" class="headerlink" title="可重复读是如何工作的?"></a>可重复读是如何工作的?</h2><p><code>可重复读隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View</code></p><ul><li>事务A在查询 example 记录过程中，事务B的 update 语句修改 example 记录会生成相应的 undo log，并以链表的方式串联起来，形成<code>版本链</code>（以前的 example 记录就变成旧版本记录，于是最新版记录和旧版本记录通过链表方式串起来。）</li><li>事务A后续去读取 example 记录时，会发现 example 记录的 trx_id 在 min_trx_id 和 max_trx_id 之间，则需要进一步判断 trx_id 是否在 m_ids 范围内。判断结果是在的那么这条记录时被修改但未提交的活跃事务，此时事务A不会读取这个版本记录。</li><li>接着沿着 undo log 版本链往下找旧版本的记录，<code>直到找到 trx_id 小于 事务A 的 Read View 的 min_trx_id 值的第一条版本的记录</code>。</li><li>最后事务 B 更新提交后，事务A查询读取记录时，还是基于启动事务时创建的 Read View 来判断当前版本记录是否可见。</li></ul><h2 id="读提交是如何工作的？"><a href="#读提交是如何工作的？" class="headerlink" title="读提交是如何工作的？"></a>读提交是如何工作的？</h2><p>读提交隔离级别是<code>每次读取数据</code>时，都会生成一个<code>新的</code> Read View</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>事务是在 MySQL 引擎层实现的。默认的 InnoDB 引擎是支持事务的。<br>事务四大特性原子性，一致性，持久性，隔离性<br>针对隔离性有如下讨论：<br>当多个事务并发执行，会引发脏读、不可重复读和幻读。<br>为了避免这些问题，SQL 提出四种隔离级别：读未提交、读提交、可重复读、串行化，左至右隔离级别越高，性能越差，InnoDB 引擎默认隔离级别是可重复读。<br>特别的，针对幻读，解决方案两种:</p><ul><li>快照读 MVCC</li><li>当前读 next-key lock 记录锁+间隙锁</li></ul><p><code>MySQL 可重复读隔离级别并没有彻底解决幻读，只是很大程度避免了幻读现象的发生</code><br>要避免这类特殊场景下发生幻读的现象，就是尽量在开启事务之后，立即执行 select…for update 这类当前读的语句，因为它会对记录加 next-key lock，从而避免其他事务插入新记录。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>事务</tag>
      
      <tag>MySQL 事务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 索引</title>
    <link href="/blog/2024/09/29/MySQL-%E7%B4%A2%E5%BC%95/"/>
    <url>/blog/2024/09/29/MySQL-%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<h2 id="知识总览"><a href="#知识总览" class="headerlink" title="知识总览"></a>知识总览</h2><p>MySQL 索引相关的内容，可以从索引原理–&gt;索引场景来展开分析，比如：</p><ul><li>索引底层使用了什么数据结构和算法？</li><li>MySQL InnoDB 为什么选择 B+ tree？</li><li>索引的优缺点？什么时候适用？什么情况会失效？</li><li>聚簇/非聚簇索引特点？</li><li>索引分类？</li><li>什么是组合、复合、联合？</li><li>InnoDB 和 MyISAM 索引区别？</li><li>索引排序内部流程是什么？</li><li>Order By 能否通过索引排序？</li><li>有什么优化索引的方法？</li><li>。。。<img src="/blog/2024/09/29/MySQL-%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E7%9F%A5%E8%AF%86%E7%9B%98%E7%82%B9.png" class=""></li></ul><h2 id="什么是索引？"><a href="#什么是索引？" class="headerlink" title="什么是索引？"></a>什么是索引？</h2><p>形象直白来讲，索引就是数据的目录。<br>所谓的存储引擎，说白就是为了如何存储数据，如何为存储数据建立<code>索引</code>和实现<code>高效CRUD操作</code>。<br>下面是 MySQL 逻辑结构缩图，索引和数据都位于存储引擎中。</p><img src="/blog/2024/09/29/MySQL-%E7%B4%A2%E5%BC%95/MySQL-%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%E5%9B%BE.png" class=""><h2 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h2><p>四个角度分类索引：</p><ul><li><code>数据结构</code>分裂： B+tree、Hash、Full-text</li><li><code>物理存储</code>分类：聚簇索引（主键索引）、二级索引（辅助索引）</li><li><code>字段特性</code>分类：主键索引、唯一索引、普通索引、前缀索引</li><li><code>字段个数</code>分类：单列索引、联合索引</li></ul><h3 id="数据结构分类"><a href="#数据结构分类" class="headerlink" title="数据结构分类"></a>数据结构分类</h3><p>从数据结构的角度来看，MySQL 常见索引有 B+tree、Hash、Full-text</p><img src="/blog/2024/09/29/MySQL-%E7%B4%A2%E5%BC%95/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%95%E6%93%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E7%B1%BB.png" class=""><p>InnoDB 在 MySQL 5.5 之后称谓默认引擎， B+tree 索引类型也是 MySQL 存储引擎采用最多的索引类型。<br>在创建表时， InnoDB 存储引擎会根据不同的场景选择不同的列作为索引：</p><ul><li>如果有主键，默认会使用主键作为聚簇索引的索引键(key);</li><li>如果没有主键，就选择第一个不包含<code>NULL</code>值的唯一列作为聚簇索引的索引键(key);</li><li>在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键(key);</li></ul><p>其他索引都属于辅助索引(Secondary Index)，也称为二级索引或非聚簇索引。<br><code>创建的主键索引和二级索引默认使用的是 B+Tree 索引</code>。</p><p>B+Tree 是一个种多叉树，叶子节点才存放数据，非叶子节点只存放索引，而且每个结点里的数据是<code>按主键顺序存档</code>的。每一层父节点的索引值都会出现在下层子结点的索引值种，因此在叶子节点中，包括了所有的索引值信息，<code>并且每一个叶子结点都有两个指针</code>,分别指向<code>下一个叶子结点</code>和<code>上一个叶子结点</code>，形成一个<code>双向链表</code>。</p><p>数据库的<code>索引</code>和<code>数据</code>都是存储在硬盘的，我们可以把读取一个结点当做一次磁盘 I/O 操作。B+Tree 先比与 B 树和二叉树来说，最大的优势在于<code>查询效率很高，因为即使在数据量很大的情况，查询一个数据的磁盘 I/O 依然维持在 3-4次</code>。</p><h4 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h4><p>如果用二级索引查询，会先检查二级索引中的 B+Tree 的索引值，在找到对应叶子节点然后获取的是主键值，然后在通过<code>主键索引的 B+Tree 树</code>找到目标主键值对应的整行数据。这个过程叫<code>回表</code>，也就是说要查 2 个 B+Tree 才能查到数据。</p><h4 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h4><p>特别地，当查询的数据是能在二级索引的 B+Tree 的叶子节点里查询到，这时就不用再去处理主键索引查询。</p><h4 id="InnoDB-默认采用-B-Tree-原因"><a href="#InnoDB-默认采用-B-Tree-原因" class="headerlink" title="InnoDB 默认采用 B+Tree 原因"></a>InnoDB 默认采用 B+Tree 原因</h4><ul><li>B+Tree <code>VS 二叉树</code> 非叶子节点不存在实际的记录数据，仅放索引，数据量相同场景下，这些非叶子节点可以存放更多的索引，所以树的高度可以很好的控制尽可能的小，因此查询底层结点磁盘 I/O 次数更少，查询效率那么就更高</li><li>B+Tree <code>VS B 树</code> 只有叶子结点存放数据，单个结点的数据量可以更小。同时有大量冗余节点（非叶子节点），这些冗余节点让插入、删除的效率都更高</li><li>B+Tree <code>VS Hash</code> 叶子节点之间用链表链接起来，有利于范围查询</li></ul><h3 id="物理存储分类"><a href="#物理存储分类" class="headerlink" title="物理存储分类"></a>物理存储分类</h3><p>从物理存储的角度来看，索引分为聚簇索引（主键索引）、二级索引（辅助索引）。<br>这两个区别：</p><ul><li>主键索引的 B+Tree 叶子节点存放的是实际数据</li><li>二级索引的 B+Tree 的叶子节点存放的都是主键值而不是实际数据，非索引覆盖场景下，存在回表操作，磁盘 I/O 开销更高，查询效率则会更低</li></ul><h3 id="字段特性分类"><a href="#字段特性分类" class="headerlink" title="字段特性分类"></a>字段特性分类</h3><p>从字段特性的角度来看，索引分为主键索引、唯一索引、普通索引、前缀索引。</p><h4 id="主键索引-PRIMARY-KEY"><a href="#主键索引-PRIMARY-KEY" class="headerlink" title="主键索引(PRIMARY KEY)"></a>主键索引(PRIMARY KEY)</h4><p>一张表最多只有一个主键索引，改索引列的值不允许有空值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">\\ 建表时<br><span class="hljs-keyword">PRIMARY</span> <span class="hljs-keyword">KEY</span> (index_column_1)<br></code></pre></td></tr></table></figure><h4 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h4><p>一张表可以有多个唯一索引，索引列的值必须唯一，但允许有空值（数据库将<code>NULL</code>视为<code>缺失值</code>）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">\\ 建表时<br><span class="hljs-keyword">UNIQUE</span> KEY (index_column_1, index_column_2, ...)<br><br>\\ 建表后，创建唯一索引：<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">UNIQUE</span> INDEX index_name<br><span class="hljs-keyword">ON</span> table_name(index_colomun_1, index_column_2, ...)<br></code></pre></td></tr></table></figure><h4 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h4><p>普通索引就是建立在普通字段上的索引，既不要求字段为主键，也不要求字段为 UNIQUE。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">\\ 建表时<br>INDEX(index_column_1, index_column_2, ...)<br><br>\\ 建表后，创建唯一索引：<br><span class="hljs-keyword">CREATE</span> INDEX index_name<br><span class="hljs-keyword">ON</span> table_name(index_colomun_1, index_column_2, ...)<br></code></pre></td></tr></table></figure><h4 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h4><p>前缀索引是指对字符类型字段的前几个字符建立的索引，而不是整个字段上建立的索引。<br>可以建立在字段类型为 char, varchar, binary, varbinary 的列上。<br>使用前缀索引的目的是<code>减少索引占用的存储空间，提升查询效率</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">\\ 建表时<br>INDEX(column_name(length))<br><br>\\ 建表后，创建唯一索引：<br><span class="hljs-keyword">CREATE</span> INDEX index_name<br><span class="hljs-keyword">ON</span> table_name(column_name(length))<br></code></pre></td></tr></table></figure><h3 id="字段个数分类"><a href="#字段个数分类" class="headerlink" title="字段个数分类"></a>字段个数分类</h3><p>从字段个数的角度来看，索引分为单列索引、联合索引（复合索引）。</p><h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><p>通过将多个字段组合成一个索引，该索引就被称为联合索引。</p><p>联合索引的非叶子节点用两个字段的值作为 B+Tree 的 key 值。<br>使用联合索引，存在<code>最左匹配原则</code>，也就是按照最左优先的方式进行索引的匹配。<br>举例联合索引(a,b,c),<code>b和c是全局无序，局部相对有序</code>,如果查询条件最左无a,那么就不满足最左匹配原则，结果就用不到联合索引了。当然利用索引的前提，还需要<code>索引里的 key 是有序的</code>。</p><h5 id="联合索引的范围查询"><a href="#联合索引的范围查询" class="headerlink" title="联合索引的范围查询"></a>联合索引的范围查询</h5><p>特殊情况：并不是查询过程使用了联合索引查询，就代表联合索引中的所有字段都用到了联合索引进行索引查询。这种情况就发生在<code>范围查询</code>。</p><p>联合索引的最左匹配原则一直向右匹配，直到遇到<code>范围查询</code>就会停止匹配。<code>也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引</code>。</p><p>可以在执行计划中的<code>key_len</code>来辨别联合索引查询过程中使用了多少个字段。（根据不同字段类型占用的字节数来比较）。<br>如下的特殊前缀匹配强调说明：</p><ul><li>区别 &gt;=、&lt;= 与 &gt;、&lt; 的区别，前者不会中止联合索引的效果</li><li>BETWEEN… AND… 在不同的数据库之下处理有差异，如果包含 = 的情况，则一样不会中止联合索引的效果</li><li>like ‘x%’ 不会中止联合索引效率。（区别于 %x，这个效率会更低）</li></ul><h5 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h5><p>对于联合索引<code>(a,b)</code>，在执行<code>select * from table where a&gt;1 and b=2</code>语句的时候，只有 a 字段用到索引，那在联合索引的 B+Tree 找到第一个满足条件的主键值（a = 2）后，还需要判断其他条件是否满足（看 b 是否等于 2），也就是<code>在联合索引遍历过程中，对联合索引中包含的字段继续做后续判断，直接过滤掉不满足条件的记录，减少回表次数</code>。（MySQL 5.6 之后引入）</p><p>当你查询的执行计划里，Extra 字段出现<code>Using index condition</code>，那么说明使用了索引下推的优化。</p><h5 id="索引区分度"><a href="#索引区分度" class="headerlink" title="索引区分度"></a>索引区分度</h5><p>建立联合索引时的字段顺序，对索引效率也有很大影响。越靠前的字段被用于索引过滤的概率越高，实际开发工作中<code>建立联合索引时，要把区分度大的字段盘在前面</code>。如<code>UUID</code>字段。</p><p>区分度就是某个字段 column 不同值的个数除以表总行数，计算公式如下：<br><code>区分度 = distinct(column) / count(*)</code></p><h2 id="创建索引的场景"><a href="#创建索引的场景" class="headerlink" title="创建索引的场景"></a>创建索引的场景</h2><p>索引的最大好处就是<code>提高查询速度</code>,但是也有缺点：</p><ul><li>需要占用物理空间，数量越大，占用空间越大</li><li>创建索引和维护索引需要耗费时间，这种时间还会伴随着数据量的增加而增大</li><li>降低表的 CRUD 效率，因为每次 CRUD 索引，B+Tree 为了维护索引有序性，都需要进行动态调整</li></ul><h3 id="什么时候适用索引？"><a href="#什么时候适用索引？" class="headerlink" title="什么时候适用索引？"></a>什么时候适用索引？</h3><ul><li>字段有唯一性限制，比如商品编码、用户 uuid</li><li>经常用于<code>WHERE</code>查询条件的字段，如果查询条件不是一个列，可以建立联合索引</li><li>经常用于<code>GROUP BY</code> 和 <code>ORDER BY</code>的字段，这样在查询的时候就不需要再去做一次排序(filesort)了，因为简历索引之后 B+Tree 的叶子节点中记录都是有序排列好的</li></ul><h3 id="什么时候不需要创建索引？"><a href="#什么时候不需要创建索引？" class="headerlink" title="什么时候不需要创建索引？"></a>什么时候不需要创建索引？</h3><ul><li>存在大量重复数据，不需要创建索引，比如性别字段</li><li>表数据太少的时候，不需要创建索引</li><li><code>WHERE、GROUP BY、ORDER BY</code> 里用不到的字段，就不需要浪费物理空间去创建索引</li><li>经常更新的字段，比如用户积分或账户余额，就不需要创建索引，因为索引字段频繁修改，由于 B+Tree 会自适应维护有序性，那么就需要频繁的重建索引，这个过程是会大大影响数据库的性能</li></ul><h3 id="有什么优化索引的方法？"><a href="#有什么优化索引的方法？" class="headerlink" title="有什么优化索引的方法？"></a>有什么优化索引的方法？</h3><ul><li>前缀索引优化</li><li>覆盖索引优化</li><li>主键索引最好是自增的</li><li>索引最好是 NOT NULL</li><li>防止索引失效</li></ul><h4 id="前缀索引优化"><a href="#前缀索引优化" class="headerlink" title="前缀索引优化"></a>前缀索引优化</h4><p>在一些大字符串的字段作索引时，使用前缀索引时为了减小索引字段大小。<br>但前缀索引也有一定局限性：</p><ul><li>order by 无法使用前缀索引</li><li>无法把前缀索引用作覆盖索引</li></ul><h4 id="覆盖索引优化"><a href="#覆盖索引优化" class="headerlink" title="覆盖索引优化"></a>覆盖索引优化</h4><p>覆盖索引指 SQL 中 query 的所有字段，在索引 B+Tree 的叶子节点上都能找得到的那些索引，从二级索引中查询得到的记录，而不需要通过聚簇索引查询获得，避免回表的操作。好处就是不需要查询包含整行记录的所有信息。</p><h4 id="主键索引最好是自增的"><a href="#主键索引最好是自增的" class="headerlink" title="主键索引最好是自增的"></a>主键索引最好是自增的</h4><p>磁盘读写的最小单位是扇区，扇区的大小只有 512B 大小，操作系统一次会读写多个扇区，所以操作系统的最小读写单位是块（Block）。Linux 中的块大小为 4KB，也就是一次磁盘  I/O 操作会直接读写 8 个扇区</p><p>如果非自增主键，由于每次插入主键的索引值都是随机的，因此每次插入新的数据时，可能会插入到现有（或已满的）数据页中某个位置，这不得不移动其他数据来满足新数据的插入，甚至需要从一个页复制数据到另一个页，通常将这种情况称为<code>页分裂</code>。页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率。</p><h4 id="防止索引失效"><a href="#防止索引失效" class="headerlink" title="防止索引失效"></a>防止索引失效</h4><p>简单总结索引失效的情况：</p><ul><li>左<code>like %x</code>或者左右<code>like %x%</code>模糊匹配</li><li>查询条件中对索引列做了计算、函数、类型转换</li><li>未遵循最左匹配原则</li><li>在<code>WHERE</code>字句中<code>OR</code>的前后条件列有一个不是索引列</li></ul><p>实际场景中，可能出现其他的索引失效，这时就需要查看执行计划，其参数有：</p><ul><li>possible_keys：可能用到的索引</li><li>key：实际用的所以，NULL 说明没有使用索引</li><li>key_len：索引的长度</li><li>rows：扫描的数据行数</li><li>type：扫描类型，执行效率低-&gt;高依次为，其中的（ALL 和 index 尽量避免）<ul><li>ALL 全表扫描</li><li>index 全索引扫描</li><li>range 索引范围扫描</li><li>ref 非唯一索引扫描</li><li>eq_ref 唯一索引扫描</li><li>const 结果只有一条的主键或唯一索引扫描</li></ul></li></ul><p>除了关注<code>Type</code>也需要关注<code>extra</code>显示的结果：</p><ul><li>❌ Using filesort<br>使用 group by 操作且无法使用索引</li><li>❌ Using temporary<br>使用 order by 或 group by 过程中保存中间结果利用了临时表</li><li>✅ Using index<br>所需数据使用了覆盖索引，避免回表操作，效率高</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL 索引</tag>
      
      <tag>索引</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 基础</title>
    <link href="/blog/2024/09/28/MySQL-%E5%9F%BA%E7%A1%80/"/>
    <url>/blog/2024/09/28/MySQL-%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="知识总览"><a href="#知识总览" class="headerlink" title="知识总览"></a>知识总览</h2><p>学习 SQL 的时候，肯定第一先学到的就是 select 查询语句，那么这个查询语句背后的实现又是如何呢？</p><h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><figure class="highlight sql"><figcaption><span>执行一条 select 查询语句</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> product <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>上述 SQL 查询语句例子在 MySQL 内部发生了什么？带着这个问题我们继续往下看，先来一个上帝视角图，去认识其内部每一个”零件”具体是负责做什么的。</p><img src="/blog/2024/09/28/MySQL-%E5%9F%BA%E7%A1%80/MySQL-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.png" class="" title="执行一条查询语句的流程图"><p>可以看到， MySQL 的架构共分为两层：<code>Server 层</code> 和 <code>存储引擎层</code></p><div class="note note-default">            <ul><li><p><code>Server 层负责建立连接、分析和执行 SQL</code>。MySQL 大多数的核心功能模块都在这实现，主要包括连接器、查询缓存、解析器、预处理器、优化器、执行器等。另外，所有的内置函数（如日期、时间、数学和加密函数等）和所有跨存储引擎的功能（如存储过程、触发器、视图等），都在 Server 层实现。</p></li><li><p><code>存储引擎层负责数据的存储和提取</code>。支持 InnoDB、MyISAM、Memory 等多个存储引擎，不同的存储引擎共用一个 Server 层。现在最常用的存储引擎（默认）是 InnoDB。我们常说的索引数据结构，就是有存储引擎层实现的，不同的存储引擎支持的索引类型也不相同，比如 InnoDB 支持索引类型（默认）是 B+ 树，也就是说在数据表中创建的主键索引和二级索引默认使用的是 B+ 树索引。</p></li></ul>          </div><p>好了，现在对 Server 层和存储引擎层有了一个简单的认识后，接下来，就详细俺看每个功能模块的作用。</p><h2 id="第一步：连接器"><a href="#第一步：连接器" class="headerlink" title="第一步：连接器"></a>第一步：连接器</h2><p>首先，需要连接 MySQL 服务，然后才能执行 SQL 语句，大部分情况都是使用这样的命令连接：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysql -h&lt;$ip&gt; -u&lt;$user&gt; -p<br></code></pre></td></tr></table></figure><p>连接的过程需要先经过 TCP 三次握手，因为 MySQL 是基于 TCP 协议进行传输的。如果用户名及密码都没有问题，连接器就会获取该用户的权限，然后保存起来，后续该用户在此丽娜姐里的任何操作，都会基于链接开始时读到的权限进行权限逻辑的判断。</p><p>所以，如果一个用户建立连接后，即使管理员中途修改了该用户的权限，也不会影响已经存在的权限。要使其修改生效，则只有用户重新建立连接才行。</p><div class="note note-warning">            <p>如何查看 MySQL 服务被多少个客户端连接了？</p>          </div><p>如果想知道当前 MySQL 服务被多少个客户端连接了，你可以执行<code>show processlist</code>命令查看。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">show</span> processlist;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+-----------------+-----------+------+---------+------+------------------------+------------------+</span><br><span class="hljs-operator">|</span> Id <span class="hljs-operator">|</span> <span class="hljs-keyword">User</span>            <span class="hljs-operator">|</span> Host      <span class="hljs-operator">|</span> db   <span class="hljs-operator">|</span> Command <span class="hljs-operator">|</span> <span class="hljs-type">Time</span> <span class="hljs-operator">|</span> State                  <span class="hljs-operator">|</span> Info             <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-----------------+-----------+------+---------+------+------------------------+------------------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">5</span> <span class="hljs-operator">|</span> event_scheduler <span class="hljs-operator">|</span> localhost <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span> Daemon  <span class="hljs-operator">|</span> <span class="hljs-number">1322</span> <span class="hljs-operator">|</span> Waiting <span class="hljs-keyword">on</span> <span class="hljs-keyword">empty</span> queue <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>             <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">12</span> <span class="hljs-operator">|</span> root            <span class="hljs-operator">|</span> localhost <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span> Sleep   <span class="hljs-operator">|</span>   <span class="hljs-number">48</span> <span class="hljs-operator">|</span>                        <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>             <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">13</span> <span class="hljs-operator">|</span> root            <span class="hljs-operator">|</span> localhost <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span> Query   <span class="hljs-operator">|</span>    <span class="hljs-number">0</span> <span class="hljs-operator">|</span> init                   <span class="hljs-operator">|</span> <span class="hljs-keyword">show</span> processlist <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-----------------+-----------+------+---------+------+------------------------+------------------+</span><br><span class="hljs-number">3</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span>, <span class="hljs-number">1</span> warning (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>空闲连接会一直占用着吗？</p>          </div><p>当然不是了，MySQL 定义了空闲连接的最大空闲时长，由<code>wait_timeout</code>参数控制，默认是 8 小时（28880 秒），如果空闲连接超过了此时间，连接器就会自动将它断开。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> &quot;wait_timeout&quot;;<br><span class="hljs-operator">+</span><span class="hljs-comment">---------------+-------+</span><br><span class="hljs-operator">|</span> Variable_name <span class="hljs-operator">|</span> <span class="hljs-keyword">Value</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------------+-------+</span><br><span class="hljs-operator">|</span> wait_timeout  <span class="hljs-operator">|</span> <span class="hljs-number">28800</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------------+-------+</span><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.01</span> sec)<br></code></pre></td></tr></table></figure><p>当然也可以手动断开空闲的连接，使用<code>kill connection &lt;$id&gt;</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">show</span> processlist;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+-----------------+-----------+------+---------+------+------------------------+------------------+</span><br><span class="hljs-operator">|</span> Id <span class="hljs-operator">|</span> <span class="hljs-keyword">User</span>            <span class="hljs-operator">|</span> Host      <span class="hljs-operator">|</span> db   <span class="hljs-operator">|</span> Command <span class="hljs-operator">|</span> <span class="hljs-type">Time</span> <span class="hljs-operator">|</span> State                  <span class="hljs-operator">|</span> Info             <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-----------------+-----------+------+---------+------+------------------------+------------------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">5</span> <span class="hljs-operator">|</span> event_scheduler <span class="hljs-operator">|</span> localhost <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span> Daemon  <span class="hljs-operator">|</span> <span class="hljs-number">1465</span> <span class="hljs-operator">|</span> Waiting <span class="hljs-keyword">on</span> <span class="hljs-keyword">empty</span> queue <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>             <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">14</span> <span class="hljs-operator">|</span> root            <span class="hljs-operator">|</span> localhost <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span> Query   <span class="hljs-operator">|</span>    <span class="hljs-number">0</span> <span class="hljs-operator">|</span> init                   <span class="hljs-operator">|</span> <span class="hljs-keyword">show</span> processlist <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">15</span> <span class="hljs-operator">|</span> root            <span class="hljs-operator">|</span> localhost <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span> Sleep   <span class="hljs-operator">|</span>    <span class="hljs-number">6</span> <span class="hljs-operator">|</span>                        <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>             <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-----------------+-----------+------+---------+------+------------------------+------------------+</span><br><span class="hljs-number">3</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span>, <span class="hljs-number">1</span> warning (<span class="hljs-number">0.00</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span> kill connection <span class="hljs-number">15</span>;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>MySQL 的连接数有限制吗？</p>          </div><p>MySQL 服务支持的最大链接数由 max_connections 参数控制，比如我的 MySQL 服务默认是 151 个，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> &quot;max_connections&quot;;<br><span class="hljs-operator">+</span><span class="hljs-comment">-----------------+-------+</span><br><span class="hljs-operator">|</span> Variable_name   <span class="hljs-operator">|</span> <span class="hljs-keyword">Value</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-----------------+-------+</span><br><span class="hljs-operator">|</span> max_connections <span class="hljs-operator">|</span> <span class="hljs-number">151</span>   <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-----------------+-------+</span><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><p>MySQL 的连接也跟 HTTP 一样，有短连接和长连接的概念，区别如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span> 短连接<br>连接 mysql 服务（TCP 三次握手）<br>执行 <span class="hljs-keyword">sql</span><br>断开 mysql 服务（TCP 四次挥手）<br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span> 长连接<br>连接 mysql 服务（TCP 三次握手）<br>执行 <span class="hljs-keyword">sql</span><br>执行 <span class="hljs-keyword">sql</span><br>执行 <span class="hljs-keyword">sql</span><br>执行 <span class="hljs-keyword">sql</span><br>...<br>断开 mysql 服务（TCP 四次挥手）<br></code></pre></td></tr></table></figure><p>可以看到，使用长连接的好处就是可以减少建立连接和断开连接时间的 IO 开销，故推荐使用长连接。</p><p>但是，使用长连接后可能会占用内存增多，因为 MySQL 在执行查询过程中临时使用内存管理连接对象，这些连接对象资源只有在连接断开时才会释放。<br>如果长连接累积到一定程度，将导致 MySQL 服务占用内存过大，会面临被系统强制中断的风险，这样会发生 MySQL 服务异常重启的现象。</p><div class="note note-warning">            <p>怎样解决长连接占用内存的问题？</p>          </div><p>两种解决方案：<code>定期断开长连接</code>和<code>客户端主动重置连接</code>。</p><p>第一种，<code>定期断开长连接</code>。既然断开连接后，就会释放连接占用的内存资源，那么我们可以定期断开长连接。<br>第二种，<code>客户端主动重置连接</code>。当客户端执行了一个很大的操作后，在代码里调用（仅存在于 MySQL<code>5.7</code>版本）内置函数 mysql_reset_connection() 来重置连接，达到释放内存的效果，这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚创建完时的状态。</p><p>至此，连接器的工作做完了，总结如下：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">* </span>与客户端进行 TCP 三次握手建立连接；<br><span class="hljs-bullet">* </span>校验客户端的用户名和密码，若校验失败则会报错；<br><span class="hljs-bullet">* </span>校验成功后，获取用户权限，然后后面的权限逻辑判断都基于此时读取到的权限。<br></code></pre></td></tr></table></figure><h2 id="第二步：查询缓存"><a href="#第二步：查询缓存" class="headerlink" title="第二步：查询缓存"></a>第二步：查询缓存</h2><p>连接器的工作完成后，客户端就可以向 MySQL 服务发送 SQL 语句了，MySQL 服务收到 SQL y语句后，就会解析出 SQL 语句的第一个字段，看看是什么类型的语句。</p><p>如果 SQL 是查询语句（<code>select</code> 语句），MySQL 就会先去查询缓存（Query Cache）里查找缓存数据，看看之前有没有执行过这一条命令，这个查询缓存时以 key-value 形式保存在内存中的，key 为 SQL 查询语句，value 为 SQL 语句查询的结果。</p><p>如果查询的语句命中查询缓存，那么就会直接返回 value 给客户端。否则，就继续往下执行，等执行完后，查询的结果就会被存入查询缓存中。</p><p>这么看，查询缓存还挺有用，但<code>对于更新频繁的表，其实查询缓存很鸡肋</code>。所以在 MySQL 8.0 版本直接将查询缓存删掉了。对于此前版本，若要关闭查询缓存可以执行命令将参数<code>query_cache_type</code>设置成DEMAND。</p><div class="note note-success">            <p>TIP<br>这里说的查询缓存时 server 层的，并不是 InnoDB 存储引擎中的 buffer pool。</p>          </div><h2 id="第三部：解析-SQL"><a href="#第三部：解析-SQL" class="headerlink" title="第三部：解析 SQL"></a>第三部：解析 SQL</h2><p>在正式执行 SQL 查询语句之前，MySQL 会先对 SQL 语句做解析，这个工作交由<code>解析器</code>来完成。</p><h3 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a>解析器</h3><p>解析器会做 <code>词法分析</code> 和 <code>语法分析</code> 这两件事：<br>第一件事，<code>词法分析</code>。MySQL 会根据你输入的字符串识别出关键字出来，例如，SQL 语句 <code>select username from userinfo</code>，在分析之后，会得到 4 个 token，其中有 2 个 keyword，分别是<code>select</code>和<code>from</code>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">+</span><span class="hljs-comment">---------+----------+-------+---------+</span><br><span class="hljs-operator">|</span>  关键字  <span class="hljs-operator">|</span> 非关键字  <span class="hljs-operator">|</span> 关键字 <span class="hljs-operator">|</span> 非关键字  <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------+----------+-------+----------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-keyword">select</span> <span class="hljs-operator">|</span> username <span class="hljs-operator">|</span> <span class="hljs-keyword">from</span>  <span class="hljs-operator">|</span> userinfo <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------+----------+-------+----------+</span><br></code></pre></td></tr></table></figure><p>第二件事，<code>语法分析</code>。分句词法分析的结果，语法解析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL yu语法，如果没问题就会构建出 SQL 语法树，这样方便后续执行流程工作模块获取 SQL 类型、表名、字段名、where 条件等等。</p><img src="/blog/2024/09/28/MySQL-%E5%9F%BA%E7%A1%80/MySQL-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90.png" class="" title="MySQL-语法分析"><p>那么通常情况下，表不存在或者字段不存在，是在解析器做的吗？</p><h2 id="第四部：执行-SQL"><a href="#第四部：执行-SQL" class="headerlink" title="第四部：执行 SQL"></a>第四部：执行 SQL</h2><p>经过解析器后，接着就要进入 SQL 查询语句的流程了，每条<code>select</code>查询语句流程重要可以分为下面三阶段：</p><ul><li>prepare，预处理</li><li>optimize，优化</li><li>execute，执行<h3 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h3>预处理阶段做了什么事情？</li><li>检查 SQL 查询语句中的表或字段是否存在；</li><li>将 select * 中的 * 符号，扩展为表上的所有数据项名称，即列。<h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3>经过预处理阶段后，还需要为 SQL 查询语句先指定一个执行计划，这个工作交由优化器来完成。<br><code>优化器主要负责将 SQL 查询语句的执行方案确定下来</code>，比如在表里有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引。<br>当然，我们本次的示例查询语句<code>select * from product where id=1</code>很简单，就是选择使用主键索引。<br>要想知道优化器选择了哪个索引，我们可以在查询语句前面加个<code>explain</code>命令，这样就会输出这条 SQL 语句的执行计划，然后执行计划中的<code>key</code>就表示执行过程中使用了哪个索引，比如下图的<code>key</code>为<code>PRIMARY</code>就是使用了主键索引，这样的执行效率最优。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> orders <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">2</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+--------+------------+-------+---------------+-----------+---------+-------+------+----------+-------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> select_type <span class="hljs-operator">|</span> <span class="hljs-keyword">table</span>  <span class="hljs-operator">|</span> partitions <span class="hljs-operator">|</span> type  <span class="hljs-operator">|</span> possible_keys <span class="hljs-operator">|</span> `key`     <span class="hljs-operator">|</span> key_len <span class="hljs-operator">|</span> <span class="hljs-keyword">ref</span>   <span class="hljs-operator">|</span> <span class="hljs-keyword">rows</span> <span class="hljs-operator">|</span> filtered <span class="hljs-operator">|</span> Extra <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+--------+------------+-------+---------------+-----------+---------+-------+------+----------+-------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> SIMPLE      <span class="hljs-operator">|</span> orders <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>       <span class="hljs-operator">|</span> const <span class="hljs-operator">|</span> <span class="hljs-keyword">PRIMARY</span>       <span class="hljs-operator">|</span> `<span class="hljs-keyword">PRIMARY</span>` <span class="hljs-operator">|</span> <span class="hljs-number">4</span>       <span class="hljs-operator">|</span> const <span class="hljs-operator">|</span>    <span class="hljs-number">1</span> <span class="hljs-operator">|</span>   <span class="hljs-number">100.00</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>  <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+--------+------------+-------+---------------+-----------+---------+-------+------+----------+-------+</span><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span>, <span class="hljs-number">1</span> warning (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><p>如果查询语句的执行计划里的<code>key</code>为<code>null</code>说明没有使用索引，俺就会全表扫描（<code>type=ALL</code>）,这样执行效率最低，如下示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> orders <span class="hljs-keyword">where</span> product_id<span class="hljs-operator">=</span><span class="hljs-number">2</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+--------+------------+--------+---------------+--------+---------+------+------+----------+-------------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> select_type <span class="hljs-operator">|</span> <span class="hljs-keyword">table</span>  <span class="hljs-operator">|</span> partitions <span class="hljs-operator">|</span> `type` <span class="hljs-operator">|</span> possible_keys <span class="hljs-operator">|</span> `key`  <span class="hljs-operator">|</span> key_len <span class="hljs-operator">|</span> <span class="hljs-keyword">ref</span>  <span class="hljs-operator">|</span> <span class="hljs-keyword">rows</span> <span class="hljs-operator">|</span> filtered <span class="hljs-operator">|</span> Extra       <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+--------+------------+--------+---------------+--------+---------+------+------+----------+-------------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> SIMPLE      <span class="hljs-operator">|</span> orders <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>       <span class="hljs-operator">|</span> `<span class="hljs-keyword">ALL</span>`  <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>          <span class="hljs-operator">|</span> `<span class="hljs-keyword">NULL</span>` <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>    <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span>    <span class="hljs-number">5</span> <span class="hljs-operator">|</span>    <span class="hljs-number">20.00</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">Using</span> <span class="hljs-keyword">where</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+--------+------------+--------+---------------+--------+---------+------+------+----------+-------------+</span><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span>, <span class="hljs-number">1</span> warning (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><p>现在给 products 表的 name 字段设置为普通索引（二级索引）：<br>这样就会出现查询语句的结果既可以使用主键索引，也可以使用普通索引，但是执行的效率会不用，这时，就需要<code>优化器</code>来决定使用哪个索引了。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> powerx.products <span class="hljs-keyword">where</span> id <span class="hljs-operator">&gt;</span> <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> name <span class="hljs-keyword">like</span> &quot;t%&quot;;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+----------+------------+-------+-----------------------+-------------+---------+------+------+----------+----------------------------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> select_type <span class="hljs-operator">|</span> <span class="hljs-keyword">table</span>    <span class="hljs-operator">|</span> partitions <span class="hljs-operator">|</span> type  <span class="hljs-operator">|</span> `possible_keys`       <span class="hljs-operator">|</span> `key`       <span class="hljs-operator">|</span> key_len <span class="hljs-operator">|</span> <span class="hljs-keyword">ref</span>  <span class="hljs-operator">|</span> <span class="hljs-keyword">rows</span> <span class="hljs-operator">|</span> filtered <span class="hljs-operator">|</span> `Extra`                    <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+----------+------------+-------+-----------------------+-------------+---------+------+------+----------+----------------------------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> SIMPLE      <span class="hljs-operator">|</span> products <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>       <span class="hljs-operator">|</span> <span class="hljs-keyword">range</span> <span class="hljs-operator">|</span> `<span class="hljs-keyword">PRIMARY</span>`,`idex_name` <span class="hljs-operator">|</span> `idex_name` <span class="hljs-operator">|</span> <span class="hljs-number">207</span>     <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span>    <span class="hljs-number">1</span> <span class="hljs-operator">|</span>    <span class="hljs-number">60.00</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">Using</span> <span class="hljs-keyword">where</span>; `<span class="hljs-keyword">Using</span> index` <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+----------+------------+-------+-----------------------+-------------+---------+------+------+----------+----------------------------+</span><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span>, <span class="hljs-number">1</span> warning (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><p>很显然这条查询语句就是<code>覆盖索引</code>，直接在二级索引就能查找到结果（因为二级索引的B+树的叶子结点的数据存储的就是主键值），就没必要再主键索引查找了，因为查询成本对比之中，主键索引的B+树 &gt; 查询二级索引的B+树，所以优化器基于查询成本的考量，会选择查询代价小的二级索引。</p><h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><p>经历完优化器后，就确定了执行方案，接下来 MySQL 就开始执行语句了，这个工作由<code>执行器</code>完成。在执行的过程中，执行器就会和存储引擎交互，交互是以<code>记录</code>为单位的。</p><p>接下来，用三种方式执行过程，来了解执行器和存储引擎的交互细节。</p><ul><li>主键索引查询</li><li>全表扫描</li><li>索引下推</li></ul><h4 id="主键索引查询"><a href="#主键索引查询" class="headerlink" title="主键索引查询"></a>主键索引查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> products <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>这条查询语句用到了主键索引，而且是等值查询，同时主键 id 是唯一，不会有 id 相同的记录，所以优化器决定选用访问类型为<code>const</code>进行查询，也就是使用主键索引查询一条记录，那么执行器与存储引擎的交互细节如下：</p><img src="/blog/2024/09/28/MySQL-%E5%9F%BA%E7%A1%80/%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E6%9F%A5%E8%AF%A2.png" class=""><h4 id="全表扫描"><a href="#全表扫描" class="headerlink" title="全表扫描"></a>全表扫描</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> products <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;product_01&#x27;</span>;<br></code></pre></td></tr></table></figure><p>这样的查询语句的查询条件没有用到索引，所以优化器决定选用访问类型为<code>ALL</code>进行查询,这时候执行器与存储引擎的执行流程是这样的：</p><img src="/blog/2024/09/28/MySQL-%E5%9F%BA%E7%A1%80/%E5%85%A8%E8%A1%A8%E6%89%AB%E6%8F%8F.png" class=""><h4 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> powerx.users <span class="hljs-keyword">where</span> username <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;user%&#x27;</span> <span class="hljs-keyword">and</span> email <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;user2@example.com&#x27;</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+-------+------------+-------+--------------------+--------------------+---------+------+------+----------+-----------------------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> select_type <span class="hljs-operator">|</span> <span class="hljs-keyword">table</span> <span class="hljs-operator">|</span> partitions <span class="hljs-operator">|</span> type  <span class="hljs-operator">|</span> possible_keys      <span class="hljs-operator">|</span> key                <span class="hljs-operator">|</span> key_len <span class="hljs-operator">|</span> <span class="hljs-keyword">ref</span>  <span class="hljs-operator">|</span> <span class="hljs-keyword">rows</span> <span class="hljs-operator">|</span> filtered <span class="hljs-operator">|</span> Extra                 <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+-------+------------+-------+--------------------+--------------------+---------+------+------+----------+-----------------------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> SIMPLE      <span class="hljs-operator">|</span> users <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>       <span class="hljs-operator">|</span> <span class="hljs-keyword">range</span> <span class="hljs-operator">|</span> idx_username_email <span class="hljs-operator">|</span> idx_username_email <span class="hljs-operator">|</span> <span class="hljs-number">404</span>     <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span>    <span class="hljs-number">5</span> <span class="hljs-operator">|</span>    <span class="hljs-number">20.00</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">Using</span> index <span class="hljs-keyword">condition</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+-------+------------+-------+--------------------+--------------------+---------+------+------+----------+-----------------------+</span><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span>, <span class="hljs-number">1</span> warning (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><p>联合索引当遇到范围查询（&gt;,&lt;）就会停止匹配，也就是<code>username</code>字段能用到联合索引，但是<code>email</code>字段则无法利用到索引。（因为范围查询之后的字段可能存在无序情况，具体分析原因见后面章节）</p><img src="/blog/2024/09/28/MySQL-%E5%9F%BA%E7%A1%80/%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8.png" class=""><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>执行一条 SQL 查询语句，期间发生了什么?</p><ul><li>连接器：建立连接，管理连接、校验用户身份；</li><li>查询缓存：查询语句若命中查询缓存则直接返回，否则继续往下执行。此模块在 8.0 版本 Deprecated；</li><li>解析 SQL：通过解析器对 SQL 查询语句进行词法分析、语法分析、构建语法树，方便后续模块读取表名、字段和语句类型；</li><li>执行 SQL：执行分三阶段：<ul><li>预处理阶段：检查表或字段是否存在，将 select * 的 * 符号扩展为表上所有列；</li><li>优化阶段：基于查询成本考量，选择查询成本最小的执行计划；</li><li>执行阶段：执行 SQL 查询语句，从存储引擎读取记录，返回客户端</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL 基础</tag>
      
      <tag>基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统-中断和异常</title>
    <link href="/blog/2021/03/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8/"/>
    <url>/blog/2021/03/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8/</url>
    
    <content type="html"><![CDATA[<h2 id="知识总览"><a href="#知识总览" class="headerlink" title="知识总览"></a>知识总览</h2><img src="/blog/2021/03/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9F%A5%E8%AF%86%E6%80%BB%E8%A7%88.png" class="" title="操作系统-中断和异常知识总览"><h2 id="中断机制的诞生"><a href="#中断机制的诞生" class="headerlink" title="中断机制的诞生"></a>中断机制的诞生</h2><p><code>背景</code>：多道处理技术之前，各个程序只能串行，导致 CPU 大部分时间处理空转等待 I/O，效率低</p><p>解决方案：为了解决上述问题，人们发明了操作系统(作为计算机的管理者)，引入中断机制，实现多道程序并发执行</p><p><code>本质</code>：<code>发生中断</code>就意味着<code>需要操作系统介入开展管理资源调度工作</code></p><h2 id="中断的概念和作用"><a href="#中断的概念和作用" class="headerlink" title="中断的概念和作用"></a>中断的概念和作用</h2><p>先来看看一个多道程序技术中中断的工作流程示例：</p><img src="/blog/2021/03/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%B8%AD%E6%96%AD%E5%B7%A5%E4%BD%9C%E7%A4%BA%E4%BE%8B.png" class="" title="操作系统-多道程序的中断工作示例"><p><code>总结</code>:<br>1、当中断发生时，CPU 立即进程<code>核心态</code><br>2、当中断发生后，当前进程暂停执行，同时由操作系统内核对中断信号进程处理<br>3、中断让操作系统获得控制权并进而开展资源调度工作，最后才能实现多道程序并发执行。</p><div class="note note-default">            <p>问：用户态、核心态之间的切换如何实现？</p><p><code>用户态 --&gt; 核心态</code>：只能通过<code>中断</code>实现<br><code>核心态 --&gt; 用户态</code>：可在<code>内核程序</code>或<code>应用程序的系统调用（归根到底还是内核程序）</code>中执行<code>特权指令</code>，对 PSW 进行设置</p>          </div><h1 id="中断的分类"><a href="#中断的分类" class="headerlink" title="中断的分类"></a>中断的分类</h1><div class="note note-default">            <p><code>内中断</code>：信号来源于 CPU 内部，与程序内容相关</p><ul><li>自愿中断–指令中断，如系统调用（trap 指令）</li><li>强迫中断<ul><li>硬件故障，如硬盘缺页</li><li>软件中断，如整数除 0</li></ul></li></ul><p><code>外中断</code>：信号来源于 CPU 外部，与程序内容无关</p><ul><li>外设中断，如 I/O 操作完成发出的中断信号</li><li>人工干预，如用户强行终止进程</li></ul>          </div><h1 id="外中断的处理过程"><a href="#外中断的处理过程" class="headerlink" title="外中断的处理过程"></a>外中断的处理过程</h1>]]></content>
    
    
    <categories>
      
      <category>中断</category>
      
    </categories>
    
    
    <tags>
      
      <tag>中断</tag>
      
      <tag>异常</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统-运行机制和体系结构</title>
    <link href="/blog/2021/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E5%92%8C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    <url>/blog/2021/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E5%92%8C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h2 id="知识总览"><a href="#知识总览" class="headerlink" title="知识总览"></a>知识总览</h2><img src="/blog/2021/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E5%92%8C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E5%92%8C%E4%BD%93%E7%B3%BB%E6%80%BB%E8%A7%88.png" class="" title="操作系统-运行机制和体系总览"><h2 id="什么是指令？"><a href="#什么是指令？" class="headerlink" title="什么是指令？"></a>什么是指令？</h2><p><code>CPU</code> 能识别并执行的最基本命令。</p><p>两种指令：</p><div class="note note-default">            <p>特权指令：如内存清零指令</p><p>非特权指令：如普通的运算指令</p>          </div><h2 id="CPU-如何判断当前是否可以执行特权指令？"><a href="#CPU-如何判断当前是否可以执行特权指令？" class="headerlink" title="CPU 如何判断当前是否可以执行特权指令？"></a>CPU 如何判断当前是否可以执行特权指令？</h2><p>用程序状态字寄存器中的<code>程序状态字</code>（<code>PSW</code>, Program Status Word）来标识当前处理器处于什么状态。如 <code>0 为用户态</code>，<code>1 为核心态</code>。</p><p>两种状态：</p><div class="note note-default">            <p>核心态（管态）：特权和非特权指令均可执行</p><p>用户态（目态）：此时 CPU 只能执行非特权指令</p>          </div><p>两种程序，内核程序和应用程序。</p><h2 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h2><p><code>内核</code>是计算机上配置的底层<code>软件</code>，是操作系统最基本、核心的部分。</p><img src="/blog/2021/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E5%92%8C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E6%A0%B8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" class="" title="操作系统-内核层次结构"><div class="note note-default">            <p>实现操作系统内核功能的那些程序就是<code>内核程序</code></p>          </div><h2 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2><p>根据<code>内核</code>结构的不同，可延伸出连两种体系结构：<code>微内核</code>、<code>大内核</code></p><div class="note note-default">            <p><code>微内核</code>：只把最基本的功能保留（如时钟管理、中断管理和原语），结构清晰方便维护，但频繁在管态和目态切换所以性能低</p><p><code>大内核</code>：除了保留微内核的基本功能，还留有进程管理、处理器管理和设备管理，结构复杂不易于维护，但性能较高</p>          </div>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>运行机制</category>
      
      <category>中断处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>中断</tag>
      
      <tag>操作系统</tag>
      
      <tag>运行机制</tag>
      
      <tag>体系结构</tag>
      
      <tag>指令</tag>
      
      <tag>内核</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统-发展和分类</title>
    <link href="/blog/2021/03/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%8F%91%E5%B1%95%E5%92%8C%E5%88%86%E7%B1%BB/"/>
    <url>/blog/2021/03/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%8F%91%E5%B1%95%E5%92%8C%E5%88%86%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="知识总览"><a href="#知识总览" class="headerlink" title="知识总览"></a>知识总览</h2><div class="note note-success">            <ul><li>操作系统的分类</li></ul>          </div><h2 id="手工操作阶段"><a href="#手工操作阶段" class="headerlink" title="手工操作阶段"></a>手工操作阶段</h2><div class="note note-default">            <p>主要缺点：用户独占全机、人机速度矛盾导致资源利用率低下</p>          </div><h2 id="批处理阶段–单道批处理系统"><a href="#批处理阶段–单道批处理系统" class="headerlink" title="批处理阶段–单道批处理系统"></a>批处理阶段–单道批处理系统</h2><p>引入脱机输入/输出技术（使用磁带完成），并<code>监督程序（操作系统雏形）</code>负责控制作业的输入、输出</p><div class="note note-default">            <p>主要优点：缓解人机速度矛盾，资源利用率提升。</p><p>主要缺点：<code>内存中只能有一道程序执行</code>，只有该程序运行结束之后才能进入下一道程序。<code>CPU 有大量的时间是在空闲等待 I/O 完成</code>，资源利用率依然很低。</p>          </div><h2 id="批处理阶段–多道批处理系统"><a href="#批处理阶段–多道批处理系统" class="headerlink" title="批处理阶段–多道批处理系统"></a>批处理阶段–多道批处理系统</h2><p>每次往内存中写入多道程序，<code>操作系统正式诞生</code>，并引入<code>中断</code>技术，由操作系统负责调度多道程序并发执行。</p><div class="note note-default">            <p>主要优点：多道程序<code>并发</code>执行，<code>共享</code>计算机资源，资源利用率大幅提升，CPU 和其他资源保持“忙碌”状态，系统吞吐量增大。</p><p>主要缺点：用户响应时间长，<code>没有人机交互功能</code>。(用户在提交作业后需要等待计算机处理完成，中间不能控制作业的执行)</p>          </div><img src="/blog/2021/03/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%8F%91%E5%B1%95%E5%92%8C%E5%88%86%E7%B1%BB/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%8D%95%E3%80%81%E5%A4%9A%E9%81%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%A4%BA%E4%BE%8B.png" class="" title="操作系统-单、多道操作系统示例"><h2 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a>分时操作系统</h2><p>计算机以<code>时间片</code>为单位轮流为各个用户/作业服务，各个用户可通过终端与计算机进行交互。</p><div class="note note-default">            <p>主要优点：用户请求即时响应，<code>解决了人机交互问题</code>。允许多个用户同时使用一台计算机。</p><p>主要缺点：<code>不能优先处理一些紧急任务</code>，操作系统对各个用户/作业都是完全公平的。</p>          </div><h2 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h2><span class="label label-success">解决及时响应紧急任务的问题。这类的紧急任务不需要时间片等待。</span><div class="note note-default">            <p>计算机系统接受到（外部）<code>中断</code>信号后及时响应处理，在严格的时限内处理完事件。</p><p>特点是<code>及时性</code>和<code>可靠性</code>。</p>          </div><img src="/blog/2021/03/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%8F%91%E5%B1%95%E5%92%8C%E5%88%86%E7%B1%BB/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%B8%A4%E7%A7%8D%E5%AE%9E%E6%97%B6%E7%B3%BB%E7%BB%9F%E7%A4%BA%E4%BE%8B.png" class="" title="操作系统-两种实时系统示例"><h2 id="分布式操作系统"><a href="#分布式操作系统" class="headerlink" title="分布式操作系统"></a>分布式操作系统</h2><p>（待续…）</p><h2 id="知识回顾"><a href="#知识回顾" class="headerlink" title="知识回顾"></a>知识回顾</h2><img src="/blog/2021/03/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%8F%91%E5%B1%95%E5%92%8C%E5%88%86%E7%B1%BB/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%88%86%E7%B1%BB%E6%80%BB%E7%BB%93.png" class="" title="操作系统-分类总结">]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>发展</tag>
      
      <tag>分类</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统-概念功能目标</title>
    <link href="/blog/2021/02/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E5%BF%B5%E5%8A%9F%E8%83%BD%E7%9B%AE%E6%A0%87/"/>
    <url>/blog/2021/02/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E5%BF%B5%E5%8A%9F%E8%83%BD%E7%9B%AE%E6%A0%87/</url>
    
    <content type="html"><![CDATA[<h2 id="知识总览"><a href="#知识总览" class="headerlink" title="知识总览"></a>知识总览</h2><div class="note note-success">            <ul><li>操作系统的概念</li><li>操作系统的功能和目标</li></ul>          </div><img src="/blog/2021/02/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E5%BF%B5%E5%8A%9F%E8%83%BD%E7%9B%AE%E6%A0%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E5%BF%B5%E5%8A%9F%E8%83%BD%E5%92%8C%E7%9B%AE%E6%A0%87-%E7%9F%A5%E8%AF%86%E6%80%BB%E8%A7%88.png" class="" title="操作系统-知识总览"><h2 id="操作系统的概念"><a href="#操作系统的概念" class="headerlink" title="操作系统的概念"></a>操作系统的概念</h2><div class="note note-default">            <p>直观的例子，打开（Mac 系统）活动监视器</p>          </div><img src="/blog/2021/02/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E5%BF%B5%E5%8A%9F%E8%83%BD%E7%9B%AE%E6%A0%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BD%AF%E7%A1%AC%E4%BB%B6%E7%AE%A1%E7%90%86%E7%9A%84%E7%A4%BA%E4%BE%8B.png" class="" title="操作系统-软硬件管理示例"><img src="/blog/2021/02/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E5%BF%B5%E5%8A%9F%E8%83%BD%E7%9B%AE%E6%A0%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E5%BF%B5.png" class="" title="操作系统-概念"><div class="note note-default">            <p>教科书解释：操作系统(Operating System, OS) </p>          </div><pre><code class="mermaid" >【从中间往上下两边看】是指控制和管理整个计算机系统的硬件和软件资源，并合理的组织调度计算机的工作和资源的分配；【从下往上看】以提供给用户和其他软件方便的接口和环境；【从上往下看】它是计算机系统中最基本的系统软件。</code></pre><h2 id="操作系统的功能和目标"><a href="#操作系统的功能和目标" class="headerlink" title="操作系统的功能和目标"></a>操作系统的功能和目标</h2><div>            <input type="checkbox" disabled ><span style="margin-left: 16px;">操作系统作为系统资源的管理者（这些资源包括软件、硬件、文件等），需要提供什么功能？</span>          </div><div>            <input type="checkbox" disabled ><span style="margin-left: 16px;">操作系统作为用户与计算机硬件之间的接口，需要为上层的用户、应用程序提供简单易用的服务，需要实现什么功能？</span>          </div><div>            <input type="checkbox" disabled ><span style="margin-left: 16px;">操作系统作为最接近硬件的层次，需要在纯硬件的基础上实现什么功能？</span>          </div><img src="/blog/2021/02/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E5%BF%B5%E5%8A%9F%E8%83%BD%E7%9B%AE%E6%A0%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%8A%9F%E8%83%BD%E5%92%8C%E7%9B%AE%E6%A0%87.png" class="" title="操作系统-功能和目标"><div class="note note-default">            <p>① 操作系统作为系统资源的管理者（这些资源包括软件、硬件、文件等），需要提供什么功能？</p>          </div><span class="label label-success">如下示例:进程是一个程序的执行过程，执行前需要`将程序放入内存中`,才能被 CPU 处理</span><img src="/blog/2021/02/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E5%BF%B5%E5%8A%9F%E8%83%BD%E7%9B%AE%E6%A0%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E8%80%85%E7%A4%BA%E4%BE%8B.png" class="" title="操作系统-资源管理者示例"><img src="/blog/2021/02/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E5%BF%B5%E5%8A%9F%E8%83%BD%E7%9B%AE%E6%A0%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%BD%9C%E4%B8%BA%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90%E7%9A%84%E7%AE%A1%E7%90%86%E8%80%85.png" class="" title="操作系统-系统资源管理者"><div class="note note-default">            <p>② 操作系统作为用户与计算机硬件之间的接口，需要为上层的用户、应用程序提供简单易用的服务，需要实现什么功能？</p>          </div><img src="/blog/2021/02/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E5%BF%B5%E5%8A%9F%E8%83%BD%E7%9B%AE%E6%A0%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%BD%9C%E4%B8%BA%E7%94%A8%E6%88%B7%E5%92%8C%E7%A1%AC%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E6%8E%A5%E5%8F%A3.png" class="" title="操作系统-作为用户和硬件之间的接口"><img src="/blog/2021/02/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E5%BF%B5%E5%8A%9F%E8%83%BD%E7%9B%AE%E6%A0%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%94%A8%E6%88%B7%E6%8E%A5%E5%8F%A3%E7%A4%BA%E4%BE%8B.png" class="" title="操作系统-用户接口示例"><div class="note note-default">            <p>③ 操作系统作为最接近硬件的层次，需要在纯硬件的基础上实现什么功能？</p>          </div><img src="/blog/2021/02/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E5%BF%B5%E5%8A%9F%E8%83%BD%E7%9B%AE%E6%A0%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%BD%9C%E4%B8%BA%E6%9C%80%E6%8E%A5%E8%BF%91%E7%A1%AC%E4%BB%B6%E7%9A%84%E5%B1%82%E6%AC%A1.png" class="" title="操作系统-作为最接近硬件的层次"><h2 id="知识回顾"><a href="#知识回顾" class="headerlink" title="知识回顾"></a>知识回顾</h2><img src="/blog/2021/02/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E5%BF%B5%E5%8A%9F%E8%83%BD%E7%9B%AE%E6%A0%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E5%BF%B5%E5%92%8C%E5%8A%9F%E8%83%BD%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE.png" class="" title="操作系统-概念和功能知识回顾">]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>功能</tag>
      
      <tag>目标</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统-基本特征</title>
    <link href="/blog/2021/02/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81/"/>
    <url>/blog/2021/02/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81/</url>
    
    <content type="html"><![CDATA[<h2 id="知识总览"><a href="#知识总览" class="headerlink" title="知识总览"></a>知识总览</h2><div class="note note-success">            <ul><li>操作系统的四个基本特征</li></ul>          </div><img src="/blog/2021/02/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%89%B9%E5%BE%81%E6%80%BB%E8%A7%88.png" class="" title="操作系统-四个基本特征"><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><div class="note note-default">            <p>指多个程序在同一<code>时间间隔内</code>发生，这些程序在<code>宏观上是同时发生</code>的。但<code>微观上是交替发生</code>的。</p>          </div><span class="label label-warning">容易混淆概念--并行: 指多个程序在同一时刻发生。</span><pre><code class="mermaid" >一个单核处理机（CPU）同一时刻只能执行一个程序因此需要操作系统负责协调多个程序交替执行（微观）对于用户看起来是同时执行（宏观）</code></pre><span class="label label-success">操作系统就是伴随“多道程序技术”而出现的。因此，操作系统和程序并发是一起诞生的。</span><h2 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h2><div class="note note-default">            <p>即资源共享，指系统中的资源可供内存中多个并发执行的进程共同使用。</p>          </div><img src="/blog/2021/02/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%85%B1%E4%BA%AB.png" class="" title="操作系统-共享"><pre><code class="mermaid" >* 互斥共享： 微信和 QQ 无法同时开启摄像头* 分时共享： 微信和 QQ "同时"传送硬盘里的文件</code></pre><img src="/blog/2021/02/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%B9%B6%E5%8F%91%E5%92%8C%E5%85%B1%E4%BA%AB%E7%9A%84%E5%85%B3%E7%B3%BB.png" class="" title="操作系统-并发和共享的关系"><h2 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h2><div class="note note-default">            <p>把物理计算资源抽象成若干个逻辑上的对应物，按时间片轮转供多个程序使用。</p>          </div><img src="/blog/2021/02/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%99%9A%E6%8B%9F%E7%A4%BA%E4%BE%8B.png" class="" title="操作系统-虚拟示例"><pre><code class="mermaid" >* 时分复用： 微观上，CPU 在各个足够小的时间片内交替为各个进程服务* 空分复用： 虚拟存储技术</code></pre><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><div class="note note-default">            <p>在多道程序环境下，允许多个程序并发执行，由于资源有限，进程的执行过程不是一贯到底而是走走停停，以不可预知的速度向前推进。</p>          </div><h2 id="知识回顾"><a href="#知识回顾" class="headerlink" title="知识回顾"></a>知识回顾</h2><img src="/blog/2021/02/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%89%B9%E5%BE%81%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE.png" class="" title="操作系统-特征知识回顾">]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>特征</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gitalk-auto-init</title>
    <link href="/blog/2021/01/18/gitalk-auto-init/"/>
    <url>/blog/2021/01/18/gitalk-auto-init/</url>
    
    <content type="html"><![CDATA[<p>  <a title="计算机基础" href="javascript:void(0);">    <img style="display:inline-block;" alt="计算机基础" src="https://img.shields.io/badge/计算机基础-多路复用-orange?style=flat">  </a>  <a title="License" href="javascript:void(0);">    <img style="display:inline-block;" alt="License" src="https://img.shields.io/github/license/fluid-dev/hexo-theme-fluid.svg?style=flat">  </a></p><span class="label label-danger">danger aa</span><div>            <input type="checkbox" disabled checked="checked"><span style="margin-left: 16px;">熟悉</span>          </div>            <input type="checkbox" disabled ><span style="margin-left: 16px;">了解</span>                      <input type="checkbox" disabled checked="checked"><span style="margin-left: 16px;">精通</span>          <pre><code class="mermaid" >这是一个大长块文字</code></pre><div class="note note-info">            <p>info 提示块标签</p>          </div><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><hr><p><em>斜体</em><br><strong>粗体</strong><br><strong><em>粗斜体</em></strong></p><p><del>删除线文本</del></p><blockquote><p><strong>这篇文章涵盖的知识点</strong><br>第一段<br>第二段引用的内容</p></blockquote><p><u>下划线文本</u></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>():</span><br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><ul><li>无序第一项<ol><li>有序子列表 1</li><li>有序子列表 2</li></ol></li><li>无序第二项</li></ul><ol><li>有序第一项<ol><li>子列表 1</li><li>子列表 2</li></ol></li><li>有序第二项<ul><li>无序子列表 1</li><li>无序子列表 2</li></ul></li></ol><p>这是一段普通的文本，其中高亮 <code>python</code> 代码块</p><p>这是超链接示例: <a href="https://www.baidu.com/">百度搜索</a></p><p>表格示例<br>| 参数 | 类型 | 值 |<br>| :—- | :—- | :—- |<br>| name | char | 必填 |<br>| age | int | 选填 |</p><p>转义字符<br>&gt;<br>\<br>* 星号<br># 井字号<br>+ 加号<br>- 减号</p><p><kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs flow">st&#x3D;&gt;start: 开始框<br>op&#x3D;&gt;operation: 处理框<br>cond&#x3D;&gt;condition: 判断框(是或否?)<br>sub1&#x3D;&gt;subroutine: 子流程<br>io&#x3D;&gt;inputoutput: 输入输出框<br>e&#x3D;&gt;end: 结束框<br>st-&gt;op-&gt;cond<br>cond(yes)-&gt;io-&gt;e<br>cond(no)-&gt;sub1(right)-&gt;op<br>​&#96;&#96;&#96;<br><br><br><br>&#123;% asset_img post-by-portal.png post-by-portal %&#125;<br>&#123;% asset_img post-by-script.png post-by-script %&#125;<br><br>&#96;&#96;&#96;python<br>#!&#x2F;usr&#x2F;bin&#x2F;env python<br># -*- coding: utf-8 -*-<br><br>import requests<br>import json<br><br>def run():<br>    username &#x3D; &#39;MengjieLee&#39;<br>    repo_name &#x3D; &#39;blog&#39;<br>    session &#x3D; requests.Session()<br>    session.auth &#x3D; (&#39;MengjieLee&#39;, &#39;Authorization: token xx&#39;)<br>    session.headers &#x3D; &#123;<br>        &#39;Accept&#39;: &#39;application&#x2F;vnd.github.v3+json&#39;,<br>        &#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;85.0.4183.59 Safari&#x2F;537.36 Edg&#x2F;85.0.564.30&#39;<br>    &#125;<br><br>    issue &#x3D; &#123;<br>        &#39;title&#39;: &#39;Python 3.6-内置函数 - Hexo&#39;,<br>        &#39;body&#39;: &#39;https:&#x2F;&#x2F;mengjielee.github.io&#x2F;blog&#x2F;2021&#x2F;01&#x2F;17&#x2F;Python-3-6-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0&#x2F;&#39;,<br>        &#39;labels&#39;: [&#39;Gitalk&#39;, &#39;c5bc3c467c6cf4ae08433c846478c9bb&#39;]<br>    &#125;<br>    github_url &#x3D; &quot;https:&#x2F;&#x2F;api.github.com&#x2F;repos&#x2F;&quot; + username + &quot;&#x2F;&quot; + repo_name + &quot;&#x2F;issues&quot;<br>    resp &#x3D; session.post(url&#x3D;github_url, data&#x3D;json.dumps(issue))<br>    print(resp)<br><br>if __name__ &#x3D;&#x3D; &#39;__main__&#39;:<br>    run()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>github</category>
      
      <category>自动化</category>
      
      <category>第三方评论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>虚拟机</title>
    <link href="/blog/2021/01/18/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <url>/blog/2021/01/18/%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Python-内置函数</title>
    <link href="/blog/2021/01/17/Python-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/"/>
    <url>/blog/2021/01/17/Python-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>多路复用</title>
    <link href="/blog/2021/01/16/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    <url>/blog/2021/01/16/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>  <a title="计算机基础" href="javascript:void(0);">    <img style="display:inline-block;" alt="计算机基础" src="https://img.shields.io/badge/计算机基础-多路复用-orange?style=flat">  </a>  <a title="License" href="javascript:void(0);">    <img style="display:inline-block;" alt="License" src="https://img.shields.io/github/license/fluid-dev/hexo-theme-fluid.svg?style=flat">  </a></p><p>???</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并发</tag>
      
      <tag>原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
